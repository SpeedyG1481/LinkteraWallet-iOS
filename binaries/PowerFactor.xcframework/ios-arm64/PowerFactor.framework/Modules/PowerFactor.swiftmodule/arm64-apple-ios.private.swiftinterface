// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 effective-4.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 4.2 -enforce-exclusivity=checked -O -module-name PowerFactor
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CommonCrypto
import CryptoKit
import Darwin
import DeveloperToolsSupport
import Dispatch
import Foundation
import LocalAuthentication
import MachO
import Foundation.NSData
import Foundation.NSUUID
import PDFKit
@_exported import PowerFactor
import SQLiteForIphoneOs
import Security
import Swift
import SwiftUI
import UIKit
import WatchConnectivity
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
public protocol ExpressionType : PowerFactor.Expressible {
  associatedtype UnderlyingType = Swift.Void
  var template: Swift.String { get }
  var bindings: [(any PowerFactor.Binding)?] { get }
  init(_ template: Swift.String, _ bindings: [(any PowerFactor.Binding)?])
}
extension PowerFactor.ExpressionType {
  public init(literal: Swift.String)
  public init(_ identifier: Swift.String)
  public init<U>(_ expression: U) where U : PowerFactor.ExpressionType
}
public struct Expression<Datatype> : PowerFactor.ExpressionType {
  public typealias UnderlyingType = Datatype
  public var template: Swift.String
  public var bindings: [(any PowerFactor.Binding)?]
  public init(_ template: Swift.String, _ bindings: [(any PowerFactor.Binding)?])
}
public protocol Expressible {
  var expression: PowerFactor.Expression<Swift.Void> { get }
}
extension PowerFactor.Expressible {
  public func asSQL() -> Swift.String
}
extension PowerFactor.ExpressionType {
  public var expression: PowerFactor.Expression<Swift.Void> {
    get
  }
  public var asc: any PowerFactor.Expressible {
    get
  }
  public var desc: any PowerFactor.Expressible {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor.Value {
  public init(value: Self.UnderlyingType)
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor._OptionalType, Self.UnderlyingType.WrappedType : PowerFactor.Value {
  public static var null: Self {
    get
  }
  public init(value: Self.UnderlyingType.WrappedType?)
}
extension PowerFactor.Value {
  public var expression: PowerFactor.Expression<Swift.Void> {
    get
  }
}
public let rowid: PowerFactor.Expression<Swift.Int64>
public func cast<T, U>(_ expression: PowerFactor.Expression<T>) -> PowerFactor.Expression<U> where T : PowerFactor.Value, U : PowerFactor.Value
public func cast<T, U>(_ expression: PowerFactor.Expression<T?>) -> PowerFactor.Expression<U?> where T : PowerFactor.Value, U : PowerFactor.Value
public struct Blob {
  public let bytes: [Swift.UInt8]
  public init(bytes: [Swift.UInt8])
  public init(bytes: Swift.UnsafeRawPointer, length: Swift.Int)
  public func toHex() -> Swift.String
}
extension PowerFactor.Blob : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension PowerFactor.Blob : Swift.Equatable {
}
public func == (lhs: PowerFactor.Blob, rhs: PowerFactor.Blob) -> Swift.Bool
public enum Collation {
  case binary
  case nocase
  case rtrim
  case custom(Swift.String)
}
extension PowerFactor.Collation : PowerFactor.Expressible {
  public var expression: PowerFactor.Expression<Swift.Void> {
    get
  }
}
extension PowerFactor.Collation : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public class CMAC : PowerFactor.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: PowerFactor.CMAC.Error, b: PowerFactor.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: any PowerFactor.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension PowerFactor.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: PowerFactor.PKCS5.PBKDF2.Error, b: PowerFactor.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: PowerFactor.HMAC.Variant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: PowerFactor.CipherError, b: PowerFactor.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension PowerFactor.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers final public class RSA {
  public enum Error : Swift.Error {
    case noPrivateKey
    case invalidInverseNotCoprimes
    case unsupportedRSAVersion
    case invalidPrimes
    case noPrimes
    case unableToCalculateCoefficient
    case invalidSignatureLength
    case invalidMessageLengthForSigning
    case invalidMessageLengthForEncryption
    case invalidDecryption
    public static func == (a: PowerFactor.RSA.Error, b: PowerFactor.RSA.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let n: PowerFactor.BigUInteger
  final public let e: PowerFactor.BigUInteger
  final public let d: PowerFactor.BigUInteger?
  final public let keySize: Swift.Int
  final public let keySizeBytes: Swift.Int
  public init(n: PowerFactor.BigUInteger, e: PowerFactor.BigUInteger, d: PowerFactor.BigUInteger? = nil)
  convenience public init(n: Swift.Array<Swift.UInt8>, e: Swift.Array<Swift.UInt8>, d: Swift.Array<Swift.UInt8>? = nil)
  convenience public init(keySize: Swift.Int) throws
  @objc deinit
}
extension PowerFactor.RSA {
  convenience public init(rawRepresentation raw: Foundation.Data) throws
}
extension PowerFactor.RSA {
  final public func externalRepresentation() throws -> Foundation.Data
  final public func publicKeyExternalRepresentation() throws -> Foundation.Data
}
extension PowerFactor.CS.BigUInt {
  public static func generatePrime(_ width: Swift.Int) -> PowerFactor.BigUInteger
}
extension PowerFactor.RSA : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : PowerFactor.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, eme_pkcs1v15, emsa_pkcs1v15, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: PowerFactor.Padding, b: PowerFactor.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class EncryptedMessage : PowerFactor.Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  public func decrypted(with key: PowerFactor.PrivateKey, padding: PowerFactor.Paddings) throws -> PowerFactor.ClearMessage
  @objc deinit
}
extension PowerFactor.AES : PowerFactor.Cryptors {
  @inlinable final public func makeEncryptor() throws -> any PowerFactor.Cryptor & PowerFactor.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> any PowerFactor.Cryptor & PowerFactor.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
@_inheritsConvenienceInitializers final public class CBCMAC : PowerFactor.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
public struct ECB : PowerFactor.BlockMode {
  public let options: PowerFactor.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
final public class GCM : PowerFactor.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: PowerFactor.GCM.Mode, b: PowerFactor.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: PowerFactor.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: PowerFactor.GCM.Error, b: PowerFactor.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: PowerFactor.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: PowerFactor.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
  @objc deinit
}
extension PowerFactor.HMAC {
  convenience public init(key: Swift.String, variant: PowerFactor.HMAC.Variant = .md5) throws
}
extension PowerFactor.Module {
  public static func FTS4(_ column: any PowerFactor.Expressible, _ more: any PowerFactor.Expressible...) -> PowerFactor.Module
  public static func FTS4(_ columns: [any PowerFactor.Expressible] = [], tokenize tokenizer: PowerFactor.Tokenizer? = nil) -> PowerFactor.Module
  public static func FTS4(_ config: PowerFactor.FTS4Config) -> PowerFactor.Module
}
extension PowerFactor.VirtualTable {
  public func match(_ pattern: Swift.String) -> PowerFactor.Expression<Swift.Bool>
  public func match(_ pattern: PowerFactor.Expression<Swift.String>) -> PowerFactor.Expression<Swift.Bool>
  public func match(_ pattern: PowerFactor.Expression<Swift.String?>) -> PowerFactor.Expression<Swift.Bool?>
  public func match(_ pattern: Swift.String) -> any PowerFactor.QueryType
  public func match(_ pattern: PowerFactor.Expression<Swift.String>) -> any PowerFactor.QueryType
  public func match(_ pattern: PowerFactor.Expression<Swift.String?>) -> any PowerFactor.QueryType
}
public struct Tokenizer {
  public static let Simple: PowerFactor.Tokenizer
  public static let Porter: PowerFactor.Tokenizer
  public static func Unicode61(removeDiacritics: Swift.Bool? = nil, tokenchars: Swift.Set<Swift.Character> = [], separators: Swift.Set<Swift.Character> = []) -> PowerFactor.Tokenizer
  public static func Custom(_ name: Swift.String) -> PowerFactor.Tokenizer
  public let name: Swift.String
  public let arguments: [Swift.String]
}
extension PowerFactor.Tokenizer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class FTSConfig {
  public enum ColumnOption {
    case unindexed
    public static func == (a: PowerFactor.FTSConfig.ColumnOption, b: PowerFactor.FTSConfig.ColumnOption) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @discardableResult
  open func column(_ column: any PowerFactor.Expressible, _ options: [PowerFactor.FTSConfig.ColumnOption] = []) -> Self
  @discardableResult
  open func columns(_ columns: [any PowerFactor.Expressible]) -> Self
  open func tokenizer(_ tokenizer: PowerFactor.Tokenizer?) -> Self
  open func prefix(_ prefix: [Swift.Int]) -> Self
  open func externalContent(_ schema: any PowerFactor.SchemaType) -> Self
  open func contentless() -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers open class FTS4Config : PowerFactor.FTSConfig {
  public enum MatchInfo : Swift.CustomStringConvertible {
    case fts3
    public var description: Swift.String {
      get
    }
    public static func == (a: PowerFactor.FTS4Config.MatchInfo, b: PowerFactor.FTS4Config.MatchInfo) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Order : Swift.CustomStringConvertible {
    case asc
    case desc
    public var description: Swift.String {
      get
    }
    public static func == (a: PowerFactor.FTS4Config.Order, b: PowerFactor.FTS4Config.Order) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init()
  open func compress(_ functionName: Swift.String) -> Self
  open func uncompress(_ functionName: Swift.String) -> Self
  open func languageId(_ columnName: Swift.String) -> Self
  open func matchInfo(_ matchInfo: PowerFactor.FTS4Config.MatchInfo) -> Self
  open func order(_ order: PowerFactor.FTS4Config.Order) -> Self
  @objc deinit
}
@objc final public class Token : ObjectiveC.NSObject {
  final public let account: Swift.String
  public enum Kind : Swift.Int {
    case totp
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers open class Code {
    open var value: Swift.String {
      get
    }
    open var from: Foundation.Date {
      get
    }
    open var to: Foundation.Date {
      get
    }
    open var currentCode: Swift.String {
      get
    }
    open var currentProgress: Swift.Int {
      get
    }
    open var remainSecond: Swift.Int {
      get
    }
    @objc deinit
  }
  final public var kind: PowerFactor.Token.Kind {
    get
  }
  final public func getCodes() -> [PowerFactor.Token.Code]
  final public func generateCode() -> PowerFactor.Token.Code
  @objc final public var issuer: Swift.String! {
    @objc get
    @objc set
  }
  @objc final public var label: Swift.String! {
    @objc get
    @objc set
  }
  @objc final public var image: Swift.String? {
    @objc get
    @objc set
  }
  public init?(otp: PowerFactor.OTP, urlc: Foundation.URLComponents, serverTimemilis: Swift.Int64, load: Swift.Bool = false)
  @objc required public init?(coder aDecoder: Foundation.NSCoder)
  @objc final public func encode(with aCoder: Foundation.NSCoder)
  @objc deinit
}
@objc(PublicKey) public class _objc_PublicKey : ObjectiveC.NSObject, PowerFactor.Key {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: PowerFactor.PublicKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc public static func publicKeys(pemEncoded pemString: Swift.String) -> [PowerFactor._objc_PublicKey]
  @objc deinit
}
@objc(PrivateKey) public class _objc_PrivateKey : ObjectiveC.NSObject, PowerFactor.Key {
  @objc public var reference: Security.SecKey {
    @objc get
  }
  @objc public var originalData: Foundation.Data? {
    @objc get
  }
  @objc public func pemString() throws -> Swift.String
  @objc public func data() throws -> Foundation.Data
  @objc public func base64String() throws -> Swift.String
  required public init(swiftValue: PowerFactor.PrivateKey)
  @objc required public init(data: Foundation.Data) throws
  @objc required public init(reference: Security.SecKey) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc required public init(pemEncoded pemString: Swift.String) throws
  @objc required public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc required public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(VerificationResult) public class _objc_VerificationResult : ObjectiveC.NSObject {
  @objc final public let isSuccessful: Swift.Bool
  @objc deinit
}
@objc(ClearMessage) public class _objc_ClearMessage : ObjectiveC.NSObject, PowerFactor.Message {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: PowerFactor.ClearMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(string: Swift.String, using rawEncoding: Swift.UInt) throws
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func string(encoding rawEncoding: Swift.UInt) throws -> Swift.String
  @objc public func encrypted(with key: PowerFactor._objc_PublicKey, padding: PowerFactor.Paddings) throws -> PowerFactor._objc_EncryptedMessage
  @objc public func signed(with key: PowerFactor._objc_PrivateKey, digestType: PowerFactor._objc_Signature.DigestType) throws -> PowerFactor._objc_Signature
  @objc public func verify(with key: PowerFactor._objc_PublicKey, signature: PowerFactor._objc_Signature, digestType: PowerFactor._objc_Signature.DigestType) throws -> PowerFactor._objc_VerificationResult
  @objc deinit
}
@objc(EncryptedMessage) public class _objc_EncryptedMessage : ObjectiveC.NSObject, PowerFactor.Message {
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: PowerFactor.EncryptedMessage)
  @objc required public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc public func decrypted(with key: PowerFactor._objc_PrivateKey, padding: PowerFactor.Paddings) throws -> PowerFactor._objc_ClearMessage
  @objc deinit
}
@objc(Signature) public class _objc_Signature : ObjectiveC.NSObject {
  @objc public enum DigestType : Swift.Int {
    case sha224
    case sha256
    case sha384
    case sha512
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc public var base64String: Swift.String {
    @objc get
  }
  @objc public var data: Foundation.Data {
    @objc get
  }
  required public init(swiftValue: PowerFactor.Signature)
  @objc public init(data: Foundation.Data)
  @objc required public init(base64Encoded base64String: Swift.String) throws
  @objc deinit
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: PowerFactor.CCM.Error, b: PowerFactor.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PowerFactor.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
}
public protocol PWFWatchDelegate {
  func onActivationStarted()
}
@objc public enum QRTransactionStatus : Swift.Int {
  case approved = 1, waitingApproval = 2, waitingSecondVerification = 3, errorOccured = 4, expired = 5, secondaryVerificationExpired = 6, secondaryVerificationRejected = 7, fraud = 8, used = 9
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension PowerFactor.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: PowerFactor.PKCS5.PBKDF1.Error, b: PowerFactor.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: PowerFactor.PKCS5.PBKDF1.Variant, b: PowerFactor.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: PowerFactor.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: PowerFactor.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
public protocol Binding {
}
public protocol Number : PowerFactor.Binding {
}
public protocol Value : PowerFactor.Expressible {
  associatedtype ValueType = Self
  associatedtype Datatype : PowerFactor.Binding
  static var declaredDatatype: Swift.String { get }
  static func fromDatatypeValue(_ datatypeValue: Self.Datatype) -> Self.ValueType
  var datatypeValue: Self.Datatype { get }
}
extension Swift.Double : PowerFactor.Number, PowerFactor.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Double) -> Swift.Double
  public var datatypeValue: Swift.Double {
    get
  }
  public typealias Datatype = Swift.Double
  public typealias ValueType = Swift.Double
}
extension Swift.Int64 : PowerFactor.Number, PowerFactor.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Int64) -> Swift.Int64
  public var datatypeValue: Swift.Int64 {
    get
  }
  public typealias Datatype = Swift.Int64
  public typealias ValueType = Swift.Int64
}
extension Swift.String : PowerFactor.Binding, PowerFactor.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.String) -> Swift.String
  public var datatypeValue: Swift.String {
    get
  }
  public typealias Datatype = Swift.String
  public typealias ValueType = Swift.String
}
extension PowerFactor.Blob : PowerFactor.Binding, PowerFactor.Value {
  public static let declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: PowerFactor.Blob) -> PowerFactor.Blob
  public var datatypeValue: PowerFactor.Blob {
    get
  }
  public typealias Datatype = PowerFactor.Blob
  public typealias ValueType = PowerFactor.Blob
}
extension Swift.Bool : PowerFactor.Binding, PowerFactor.Value {
  public static var declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Int64) -> Swift.Bool
  public var datatypeValue: Swift.Int64 {
    get
  }
  public typealias Datatype = Swift.Int64
  public typealias ValueType = Swift.Bool
}
extension Swift.Int : PowerFactor.Number, PowerFactor.Value {
  public static var declaredDatatype: Swift.String
  public static func fromDatatypeValue(_ datatypeValue: Swift.Int64) -> Swift.Int
  public var datatypeValue: Swift.Int64 {
    get
  }
  public typealias Datatype = Swift.Int64
  public typealias ValueType = Swift.Int
}
@objc @_inheritsConvenienceInitializers @objcMembers open class PWFLoginResponse : ObjectiveC.NSObject {
  @objc open var LoginOtp: Swift.String?
  @objc open var ActivationToken: Swift.String?
  @objc public init(loginOtp: Swift.String?, activationToken: Swift.String?)
  @objc override dynamic public init()
  @objc deinit
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : PowerFactor._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [PowerFactor.Bit]
  public func bits() -> Swift.String
}
public struct CBC : PowerFactor.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PowerFactor.CBC.Error, b: PowerFactor.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PowerFactor.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
}
@objc @objcMembers open class PWFUserContract : PowerFactor.PWFBaseObject {
  @objc open var CustomerId: Swift.Int64
  @objc open var IsBiometricEnable: Swift.Bool
  @objc open var IsSE: Swift.Bool
  open var Status: Swift.Int?
  @objc public init(customerId: Swift.Int64)
  @objc public init(customerId: Swift.Int64, isBiometricEnable: Swift.Bool)
  @objc public init(customerId: Swift.Int64, isBiometricEnable: Swift.Bool, isSE: Swift.Bool, activationRef: Swift.String?)
  override public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension PowerFactor.MD5 : PowerFactor.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public enum PWFClientLogTypes : Swift.Int16 {
  case error, unhandled, info, trace
  public init?(rawValue: Swift.Int16)
  public typealias RawValue = Swift.Int16
  public var rawValue: Swift.Int16 {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor.Value {
  public var distinct: PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
  public var count: PowerFactor.Expression<Swift.Int> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor._OptionalType, Self.UnderlyingType.WrappedType : PowerFactor.Value {
  public var distinct: PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
  public var count: PowerFactor.Expression<Swift.Int> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor.Value, Self.UnderlyingType.Datatype : Swift.Comparable {
  public var max: PowerFactor.Expression<Self.UnderlyingType?> {
    get
  }
  public var min: PowerFactor.Expression<Self.UnderlyingType?> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor._OptionalType, Self.UnderlyingType.WrappedType : PowerFactor.Value, Self.UnderlyingType.WrappedType.Datatype : Swift.Comparable {
  public var max: PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
  public var min: PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor.Value, Self.UnderlyingType.Datatype : PowerFactor.Number {
  public var average: PowerFactor.Expression<Swift.Double?> {
    get
  }
  public var sum: PowerFactor.Expression<Self.UnderlyingType?> {
    get
  }
  public var total: PowerFactor.Expression<Swift.Double> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor._OptionalType, Self.UnderlyingType.WrappedType : PowerFactor.Value, Self.UnderlyingType.WrappedType.Datatype : PowerFactor.Number {
  public var average: PowerFactor.Expression<Swift.Double?> {
    get
  }
  public var sum: PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
  public var total: PowerFactor.Expression<Swift.Double> {
    get
  }
}
public func count(_ star: (PowerFactor.Expression<any PowerFactor.Binding>?, PowerFactor.Expression<any PowerFactor.Binding>?) -> PowerFactor.Expression<Swift.Void>) -> PowerFactor.Expression<Swift.Int>
public enum PKCS7 {
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension PowerFactor.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension PowerFactor.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: PowerFactor.BatchedCollectionIndex<Base>, rhs: PowerFactor.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: PowerFactor.BatchedCollectionIndex<Base>, rhs: PowerFactor.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = PowerFactor.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: PowerFactor.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: PowerFactor.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: PowerFactor.BatchedCollection<Base>.Index) -> PowerFactor.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: PowerFactor.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<PowerFactor.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<PowerFactor.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<PowerFactor.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> PowerFactor.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
public class Signature {
  public enum DigestType {
    case sha224
    case sha256
    case sha384
    case sha512
    public static func == (a: PowerFactor.Signature.DigestType, b: PowerFactor.Signature.DigestType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
final public class SHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension PowerFactor.SHA1 : PowerFactor.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
public struct CompressionLevel : Swift.RawRepresentable {
  public let rawValue: Swift.Int32
  public static let noCompression: PowerFactor.CompressionLevel
  public static let bestSpeed: PowerFactor.CompressionLevel
  public static let bestCompression: PowerFactor.CompressionLevel
  public static let defaultCompression: PowerFactor.CompressionLevel
  public init(rawValue: Swift.Int32)
  public init(_ rawValue: Swift.Int32)
  public typealias RawValue = Swift.Int32
}
public struct GzipError : Swift.Error {
  public enum Kind : Swift.Equatable {
    case stream
    case data
    case memory
    case buffer
    case version
    case unknown(code: Swift.Int)
    public static func == (a: PowerFactor.GzipError.Kind, b: PowerFactor.GzipError.Kind) -> Swift.Bool
  }
  public let kind: PowerFactor.GzipError.Kind
  public let message: Swift.String
  public var localizedDescription: Swift.String {
    get
  }
}
extension Foundation.Data {
  public var isGzipped: Swift.Bool {
    get
  }
  public func gzipped(level: PowerFactor.CompressionLevel = .defaultCompression) throws -> Foundation.Data
  public func gunzipped() throws -> Foundation.Data
}
public func base32Encode(_ data: Foundation.Data) -> Swift.String
public func base32HexEncode(_ data: Foundation.Data) -> Swift.String
public func base32DecodeToData(_ string: Swift.String) -> Foundation.Data?
public func base32HexDecodeToData(_ string: Swift.String) -> Foundation.Data?
public func base32Encode(_ array: [Swift.UInt8]) -> Swift.String
public func base32HexEncode(_ array: [Swift.UInt8]) -> Swift.String
public func base32Decode(_ string: Swift.String) -> [Swift.UInt8]?
public func base32HexDecode(_ string: Swift.String) -> [Swift.UInt8]?
extension Swift.String {
  public var base32DecodedData: Foundation.Data? {
    get
  }
  public var base32EncodedString: Swift.String {
    get
  }
  public func base32DecodedString(_ encoding: Swift.String.Encoding = .utf8) -> Swift.String?
  public var base32HexDecodedData: Foundation.Data? {
    get
  }
  public var base32HexEncodedString: Swift.String {
    get
  }
  public func base32HexDecodedString(_ encoding: Swift.String.Encoding = .utf8) -> Swift.String?
}
extension Foundation.Data {
  public var base32EncodedString: Swift.String {
    get
  }
  public var base32DecodedData: Foundation.Data? {
    get
  }
  public var base32HexEncodedString: Swift.String {
    get
  }
  public var base32HexDecodedData: Foundation.Data? {
    get
  }
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: PowerFactor.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
extension PowerFactor.CS.BigUInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension PowerFactor.CS.BigInt {
  public init?<S>(_ text: S, radix: Swift.Int = 10) where S : Swift.StringProtocol
}
extension Swift.String {
  public init(_ v: PowerFactor.CS.BigUInt)
  public init(_ v: PowerFactor.CS.BigUInt, radix: Swift.Int, uppercase: Swift.Bool = false)
  public init(_ value: PowerFactor.CS.BigInt, radix: Swift.Int = 10, uppercase: Swift.Bool = false)
}
extension PowerFactor.CS.BigUInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension PowerFactor.CS.BigInt : Swift.ExpressibleByStringLiteral {
  public init(unicodeScalarLiteral value: Swift.UnicodeScalar)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.UnicodeScalar
}
extension PowerFactor.CS.BigUInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension PowerFactor.CS.BigInt : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension PowerFactor.CS.BigUInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
extension PowerFactor.CS.BigInt : Swift.CustomPlaygroundDisplayConvertible {
  public var playgroundDescription: Any {
    get
  }
}
final public class HMAC : PowerFactor.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: PowerFactor.HMAC.Error, b: PowerFactor.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case md5
    case sha1
    case sha2(PowerFactor.SHA2.Variant)
    case sha3(PowerFactor.SHA3.Variant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256, sha384, sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: PowerFactor.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@_inheritsConvenienceInitializers @objc open class ApproveQRTransactionResponse : ObjectiveC.NSObject {
  open var SecondaryVerificationCode: Swift.String?
  open var SecondaryVerificationTimeoutDuration: Swift.String?
  open var QRTrancationStatus: PowerFactor.QRTransactionStatus?
  @objc override dynamic public init()
  @objc deinit
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: PowerFactor.ChaCha20.Error, b: PowerFactor.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension PowerFactor.ChaCha20 : PowerFactor.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension PowerFactor.ChaCha20 {
  public struct ChaChaEncryptor : PowerFactor.Cryptor, PowerFactor.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension PowerFactor.ChaCha20 {
  public struct ChaChaDecryptor : PowerFactor.Cryptor, PowerFactor.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension PowerFactor.ChaCha20 : PowerFactor.Cryptors {
  final public func makeEncryptor() -> any PowerFactor.Cryptor & PowerFactor.Updatable
  final public func makeDecryptor() -> any PowerFactor.Cryptor & PowerFactor.Updatable
}
extension PowerFactor.CS {
  public struct BigInt : Swift.SignedInteger {
    public enum Sign {
      case plus
      case minus
      public static func == (a: PowerFactor.CS.BigInt.Sign, b: PowerFactor.CS.BigInt.Sign) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public typealias Magnitude = PowerFactor.CS.BigUInt
    public typealias Word = PowerFactor.CS.BigUInt.Word
    public static var isSigned: Swift.Bool {
      get
    }
    public var magnitude: PowerFactor.CS.BigUInt
    public var sign: PowerFactor.CS.BigInt.Sign
    public init(sign: PowerFactor.CS.BigInt.Sign, magnitude: PowerFactor.CS.BigUInt)
    public var isZero: Swift.Bool {
      get
    }
    public func signum() -> PowerFactor.CS.BigInt
  }
}
public protocol Key : AnyObject {
  var reference: Security.SecKey { get }
  var originalData: Foundation.Data? { get }
  init(data: Foundation.Data) throws
  init(reference: Security.SecKey) throws
  init(base64Encoded base64String: Swift.String) throws
  init(pemEncoded pemString: Swift.String) throws
  init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  func pemString() throws -> Swift.String
  func data() throws -> Foundation.Data
  func base64String() throws -> Swift.String
}
extension PowerFactor.Key {
  public func base64String() throws -> Swift.String
  public func data() throws -> Foundation.Data
  public init(base64Encoded base64String: Swift.String) throws
  public init(pemEncoded pemString: Swift.String) throws
  public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
}
public protocol QueryType : PowerFactor.Expressible {
  var clauses: PowerFactor.QueryClauses { get set }
  init(_ name: Swift.String, database: Swift.String?)
}
public protocol SchemaType : PowerFactor.QueryType {
  static var identifier: Swift.String { get }
}
extension PowerFactor.SchemaType {
  public func select(_ column1: any PowerFactor.Expressible, _ more: any PowerFactor.Expressible...) -> Self
  public func select(distinct column1: any PowerFactor.Expressible, _ more: any PowerFactor.Expressible...) -> Self
  public func select(_ all: [any PowerFactor.Expressible]) -> Self
  public func select(distinct columns: [any PowerFactor.Expressible]) -> Self
  public func select(_ star: (PowerFactor.Expression<any PowerFactor.Binding>?, PowerFactor.Expression<any PowerFactor.Binding>?) -> PowerFactor.Expression<Swift.Void>) -> Self
  public func select(distinct star: (PowerFactor.Expression<any PowerFactor.Binding>?, PowerFactor.Expression<any PowerFactor.Binding>?) -> PowerFactor.Expression<Swift.Void>) -> Self
  public func select<V>(_ column: PowerFactor.Expression<V>) -> PowerFactor.ScalarQuery<V> where V : PowerFactor.Value
  public func select<V>(_ column: PowerFactor.Expression<V?>) -> PowerFactor.ScalarQuery<V?> where V : PowerFactor.Value
  public func select<V>(distinct column: PowerFactor.Expression<V>) -> PowerFactor.ScalarQuery<V> where V : PowerFactor.Value
  public func select<V>(distinct column: PowerFactor.Expression<V?>) -> PowerFactor.ScalarQuery<V?> where V : PowerFactor.Value
  public var count: PowerFactor.ScalarQuery<Swift.Int> {
    get
  }
}
extension PowerFactor.QueryType {
  public func join(_ table: any PowerFactor.QueryType, on condition: PowerFactor.Expression<Swift.Bool>) -> Self
  public func join(_ table: any PowerFactor.QueryType, on condition: PowerFactor.Expression<Swift.Bool?>) -> Self
  public func join(_ type: PowerFactor.JoinType, _ table: any PowerFactor.QueryType, on condition: PowerFactor.Expression<Swift.Bool>) -> Self
  public func join(_ type: PowerFactor.JoinType, _ table: any PowerFactor.QueryType, on condition: PowerFactor.Expression<Swift.Bool?>) -> Self
  public func filter(_ predicate: PowerFactor.Expression<Swift.Bool>) -> Self
  public func filter(_ predicate: PowerFactor.Expression<Swift.Bool?>) -> Self
  public func group(_ by: any PowerFactor.Expressible...) -> Self
  public func group(_ by: [any PowerFactor.Expressible]) -> Self
  public func group(_ by: any PowerFactor.Expressible, having: PowerFactor.Expression<Swift.Bool>) -> Self
  public func group(_ by: any PowerFactor.Expressible, having: PowerFactor.Expression<Swift.Bool?>) -> Self
  public func group(_ by: [any PowerFactor.Expressible], having: PowerFactor.Expression<Swift.Bool>) -> Self
  public func group(_ by: [any PowerFactor.Expressible], having: PowerFactor.Expression<Swift.Bool?>) -> Self
  public func order(_ by: any PowerFactor.Expressible...) -> Self
  public func order(_ by: [any PowerFactor.Expressible]) -> Self
  public func limit(_ length: Swift.Int?) -> Self
  public func limit(_ length: Swift.Int, offset: Swift.Int) -> Self
  public func alias(_ aliasName: Swift.String) -> Self
  public func insert(_ value: PowerFactor.Setter, _ more: PowerFactor.Setter...) -> PowerFactor.Insert
  public func insert(_ values: [PowerFactor.Setter]) -> PowerFactor.Insert
  public func insert(or onConflict: PowerFactor.OnConflict, _ values: PowerFactor.Setter...) -> PowerFactor.Insert
  public func insert(or onConflict: PowerFactor.OnConflict, _ values: [PowerFactor.Setter]) -> PowerFactor.Insert
  public func insert() -> PowerFactor.Insert
  public func insert(_ query: any PowerFactor.QueryType) -> PowerFactor.Update
  public func update(_ values: PowerFactor.Setter...) -> PowerFactor.Update
  public func update(_ values: [PowerFactor.Setter]) -> PowerFactor.Update
  public func delete() -> PowerFactor.Delete
  public var exists: PowerFactor.Select<Swift.Bool> {
    get
  }
  public func namespace<V>(_ column: PowerFactor.Expression<V>) -> PowerFactor.Expression<V>
  public subscript(column: PowerFactor.Expression<PowerFactor.Blob>) -> PowerFactor.Expression<PowerFactor.Blob> {
    get
  }
  public subscript(column: PowerFactor.Expression<PowerFactor.Blob?>) -> PowerFactor.Expression<PowerFactor.Blob?> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Double>) -> PowerFactor.Expression<Swift.Double> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Double?>) -> PowerFactor.Expression<Swift.Double?> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int>) -> PowerFactor.Expression<Swift.Int> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int?>) -> PowerFactor.Expression<Swift.Int?> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int64>) -> PowerFactor.Expression<Swift.Int64> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int64?>) -> PowerFactor.Expression<Swift.Int64?> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.String>) -> PowerFactor.Expression<Swift.String> {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.String?>) -> PowerFactor.Expression<Swift.String?> {
    get
  }
  public subscript(star: (PowerFactor.Expression<any PowerFactor.Binding>?, PowerFactor.Expression<any PowerFactor.Binding>?) -> PowerFactor.Expression<Swift.Void>) -> PowerFactor.Expression<Swift.Void> {
    get
  }
  public var expression: PowerFactor.Expression<Swift.Void> {
    get
  }
}
public struct Table : PowerFactor.SchemaType {
  public static let identifier: Swift.String
  public var clauses: PowerFactor.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct View : PowerFactor.SchemaType {
  public static let identifier: Swift.String
  public var clauses: PowerFactor.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct VirtualTable : PowerFactor.SchemaType {
  public static let identifier: Swift.String
  public var clauses: PowerFactor.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct ScalarQuery<V> : PowerFactor.QueryType {
  public var clauses: PowerFactor.QueryClauses
  public init(_ name: Swift.String, database: Swift.String? = nil)
}
public struct Select<T> : PowerFactor.ExpressionType {
  public var template: Swift.String
  public var bindings: [(any PowerFactor.Binding)?]
  public init(_ template: Swift.String, _ bindings: [(any PowerFactor.Binding)?])
  public typealias UnderlyingType = Swift.Void
}
public struct Insert : PowerFactor.ExpressionType {
  public var template: Swift.String
  public var bindings: [(any PowerFactor.Binding)?]
  public init(_ template: Swift.String, _ bindings: [(any PowerFactor.Binding)?])
  public typealias UnderlyingType = Swift.Void
}
public struct Update : PowerFactor.ExpressionType {
  public var template: Swift.String
  public var bindings: [(any PowerFactor.Binding)?]
  public init(_ template: Swift.String, _ bindings: [(any PowerFactor.Binding)?])
  public typealias UnderlyingType = Swift.Void
}
public struct Delete : PowerFactor.ExpressionType {
  public var template: Swift.String
  public var bindings: [(any PowerFactor.Binding)?]
  public init(_ template: Swift.String, _ bindings: [(any PowerFactor.Binding)?])
  public typealias UnderlyingType = Swift.Void
}
extension PowerFactor.Connection {
  final public func prepare(_ query: any PowerFactor.QueryType) throws -> Swift.AnySequence<PowerFactor.Row>
  final public func scalar<V>(_ query: PowerFactor.ScalarQuery<V>) throws -> V where V : PowerFactor.Value
  final public func scalar<V>(_ query: PowerFactor.ScalarQuery<V?>) throws -> V.ValueType? where V : PowerFactor.Value
  final public func scalar<V>(_ query: PowerFactor.Select<V>) throws -> V where V : PowerFactor.Value
  final public func scalar<V>(_ query: PowerFactor.Select<V?>) throws -> V.ValueType? where V : PowerFactor.Value
  final public func pluck(_ query: any PowerFactor.QueryType) throws -> PowerFactor.Row?
  final public func run(_ query: PowerFactor.Insert) throws -> Swift.Int64
  final public func run(_ query: PowerFactor.Update) throws -> Swift.Int
  final public func run(_ query: PowerFactor.Delete) throws -> Swift.Int
}
public struct Row {
  public func get<V>(_ column: PowerFactor.Expression<V>) -> V where V : PowerFactor.Value
  public func get<V>(_ column: PowerFactor.Expression<V?>) -> V? where V : PowerFactor.Value
  public subscript(column: PowerFactor.Expression<PowerFactor.Blob>) -> PowerFactor.Blob {
    get
  }
  public subscript(column: PowerFactor.Expression<PowerFactor.Blob?>) -> PowerFactor.Blob? {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Bool>) -> Swift.Bool {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Bool?>) -> Swift.Bool? {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Double>) -> Swift.Double {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Double?>) -> Swift.Double? {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int>) -> Swift.Int {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int?>) -> Swift.Int? {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int64>) -> Swift.Int64 {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.Int64?>) -> Swift.Int64? {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.String>) -> Swift.String {
    get
  }
  public subscript(column: PowerFactor.Expression<Swift.String?>) -> Swift.String? {
    get
  }
}
public enum JoinType : Swift.String {
  case Cross
  case Inner
  case LeftOuter
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum OnConflict : Swift.String {
  case Replace
  case Rollback
  case Abort
  case Fail
  case Ignore
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct QueryClauses {
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: PowerFactor.SHA3.Variant, b: PowerFactor.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: PowerFactor.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension PowerFactor.SHA3 : PowerFactor.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
final public class SoftOtp {
  public init()
  public init(isActive: Swift.Bool, otpData: Swift.String, serverTimemilis: Swift.Int64)
  final public func tokenListener(tokenCallback callback: @escaping (_ token: PowerFactor.PWFSoftOtpToken) -> Swift.Void) -> (Swift.String)?
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension PowerFactor.Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
extension PowerFactor.CS.BigUInt {
  public subscript(bitAt index: Swift.Int) -> Swift.Bool {
    get
    set
  }
}
extension PowerFactor.CS.BigUInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var leadingZeroBitCount: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension PowerFactor.CS.BigInt {
  public var bitWidth: Swift.Int {
    get
  }
  public var trailingZeroBitCount: Swift.Int {
    get
  }
}
extension PowerFactor.CS.BigUInt {
  public struct Words : Swift.RandomAccessCollection {
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> PowerFactor.CS.BigUInt.Word {
      get
    }
    public typealias Element = PowerFactor.CS.BigUInt.Word
    public typealias Index = Swift.Int
    public typealias Indices = Swift.Range<Swift.Int>
    public typealias Iterator = Swift.IndexingIterator<PowerFactor.CS.BigUInt.Words>
    public typealias SubSequence = Swift.Slice<PowerFactor.CS.BigUInt.Words>
  }
  public var words: PowerFactor.CS.BigUInt.Words {
    get
  }
  public init<Words>(words: Words) where Words : Swift.Sequence, Words.Element == Swift.UInt
}
extension PowerFactor.CS.BigInt {
  public struct Words : Swift.RandomAccessCollection {
    public typealias Indices = Swift.CountableRange<Swift.Int>
    public var count: Swift.Int {
      get
    }
    public var indices: PowerFactor.CS.BigInt.Words.Indices {
      get
    }
    public var startIndex: Swift.Int {
      get
    }
    public var endIndex: Swift.Int {
      get
    }
    public subscript(index: Swift.Int) -> Swift.UInt {
      get
    }
    public typealias Element = Swift.UInt
    public typealias Index = Swift.Int
    public typealias Iterator = Swift.IndexingIterator<PowerFactor.CS.BigInt.Words>
    public typealias SubSequence = Swift.Slice<PowerFactor.CS.BigInt.Words>
  }
  public var words: PowerFactor.CS.BigInt.Words {
    get
  }
  public init<S>(words: S) where S : Swift.Sequence, S.Element == Swift.UInt
}
extension PowerFactor.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
public protocol Message {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
  init(base64Encoded base64String: Swift.String) throws
}
extension PowerFactor.Message {
  public var base64String: Swift.String {
    get
  }
  public init(base64Encoded base64String: Swift.String) throws
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: PowerFactor.HKDF.Error, b: PowerFactor.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: PowerFactor.HMAC.Variant = .sha2(.sha256)) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits  448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
extension PowerFactor.CS.BigUInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension PowerFactor.CS.BigInt {
  public init(_ buffer: Swift.UnsafeRawBufferPointer)
  public init(_ data: Foundation.Data)
  public func serialize() -> Foundation.Data
}
extension Foundation.Data : PowerFactor.Value {
  public static var declaredDatatype: Swift.String {
    get
  }
  public static func fromDatatypeValue(_ dataValue: PowerFactor.Blob) -> Foundation.Data
  public var datatypeValue: PowerFactor.Blob {
    get
  }
  public typealias Datatype = PowerFactor.Blob
  public typealias ValueType = Foundation.Data
}
extension Foundation.Date : PowerFactor.Value {
  public static var declaredDatatype: Swift.String {
    get
  }
  public static func fromDatatypeValue(_ stringValue: Swift.String) -> Foundation.Date
  public var datatypeValue: Swift.String {
    get
  }
  public typealias Datatype = Swift.String
  public typealias ValueType = Foundation.Date
}
public var dateFormatter: Foundation.DateFormatter
extension PowerFactor.QueryType {
  public subscript(column: PowerFactor.Expression<Foundation.Data>) -> PowerFactor.Expression<Foundation.Data> {
    get
  }
  public subscript(column: PowerFactor.Expression<Foundation.Data?>) -> PowerFactor.Expression<Foundation.Data?> {
    get
  }
  public subscript(column: PowerFactor.Expression<Foundation.Date>) -> PowerFactor.Expression<Foundation.Date> {
    get
  }
  public subscript(column: PowerFactor.Expression<Foundation.Date?>) -> PowerFactor.Expression<Foundation.Date?> {
    get
  }
}
extension PowerFactor.Row {
  public subscript(column: PowerFactor.Expression<Foundation.Data>) -> Foundation.Data {
    get
  }
  public subscript(column: PowerFactor.Expression<Foundation.Data?>) -> Foundation.Data? {
    get
  }
  public subscript(column: PowerFactor.Expression<Foundation.Date>) -> Foundation.Date {
    get
  }
  public subscript(column: PowerFactor.Expression<Foundation.Date?>) -> Foundation.Date? {
    get
  }
}
extension PowerFactor.CS.BigUInt {
  public mutating func multiply(byWord y: PowerFactor.CS.BigUInt.Word)
  public func multiplied(byWord y: PowerFactor.CS.BigUInt.Word) -> PowerFactor.CS.BigUInt
  public mutating func multiplyAndAdd(_ x: PowerFactor.CS.BigUInt, _ y: PowerFactor.CS.BigUInt.Word, shiftedBy shift: Swift.Int = 0)
  public func multiplied(by y: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public static var directMultiplicationLimit: Swift.Int
  public static func * (x: PowerFactor.CS.BigUInt, y: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public static func *= (a: inout PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt)
}
extension PowerFactor.CS.BigInt {
  public static func * (a: PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func *= (a: inout PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt)
}
@usableFromInline
final internal class StreamEncryptor : PowerFactor.Cryptor, PowerFactor.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any PowerFactor.CipherModeWorker
  @usableFromInline
  final internal let padding: PowerFactor.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PowerFactor.Padding, _ worker: any PowerFactor.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
@objc @_inheritsConvenienceInitializers @objcMembers open class PWFTransactionContract : ObjectiveC.NSObject {
  @objc open var TransactionContent: Swift.String?
  @objc open var TransactionToken: Swift.String?
  @objc open var TransactionName: Swift.String?
  @objc open var TransactionBeginDate: Swift.String?
  @objc open var TransactionType: Swift.String?
  @objc open var TransactionApprovementTypeList: [Swift.Int]?
  @objc open var TransactionRemainingTime: Swift.Int
  @objc open var CancelOnBackPress: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
extension PowerFactor.CS.BigUInt {
  public static func randomInteger<RNG>(withMaximumWidth width: Swift.Int, using generator: inout RNG) -> PowerFactor.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withMaximumWidth width: Swift.Int) -> PowerFactor.CS.BigUInt
  public static func randomInteger<RNG>(withExactWidth width: Swift.Int, using generator: inout RNG) -> PowerFactor.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(withExactWidth width: Swift.Int) -> PowerFactor.CS.BigUInt
  public static func randomInteger<RNG>(lessThan limit: PowerFactor.CS.BigUInt, using generator: inout RNG) -> PowerFactor.CS.BigUInt where RNG : Swift.RandomNumberGenerator
  public static func randomInteger(lessThan limit: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
}
public class PWFConfig {
  public enum `Type` {
    case bundleConfigName
    case fileConfigName
    case configContent
    public static func == (a: PowerFactor.PWFConfig.`Type`, b: PowerFactor.PWFConfig.`Type`) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(value: Swift.String, type: PowerFactor.PWFConfig.`Type`)
  @objc deinit
}
extension PowerFactor.CS.BigUInt {
  public func isStrongProbablePrime(_ base: PowerFactor.CS.BigUInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
extension PowerFactor.CS.BigInt {
  public func isStrongProbablePrime(_ base: PowerFactor.CS.BigInt) -> Swift.Bool
  public func isPrime(rounds: Swift.Int = 10) -> Swift.Bool
}
public enum SwiftyRSAError : Swift.Error {
  case pemDoesNotContainKey
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
  case keyGenerationFailed(error: CoreFoundation.CFError?)
  case keyCreateFailed(error: CoreFoundation.CFError?)
  case keyAddFailed(status: Darwin.OSStatus)
  case keyCopyFailed(status: Darwin.OSStatus)
  case tagEncodingFailed
  case asn1ParsingFailed
  case invalidAsn1RootNode
  case invalidAsn1Structure
  case invalidBase64String
  case chunkDecryptFailed(index: Swift.Int)
  case chunkEncryptFailed(index: Swift.Int)
  case stringToDataConversionFailed
  case dataToStringConversionFailed
  case invalidDigestSize(digestSize: Swift.Int, maxChunkSize: Swift.Int)
  case signatureCreateFailed(status: Darwin.OSStatus)
  case signatureVerifyFailed(status: Darwin.OSStatus)
  case pemFileNotFound(name: Swift.String)
  case derFileNotFound(name: Swift.String)
  case notAPublicKey
  case notAPrivateKey
  case privateKeyNotDeleted
  case keypairGenerateFailedAlert
  case keypairGenerateFailed
  case creatingKeyPairSuccessful
  case publicKeySaveFailedAlert
  case publicKeySaveFailed
  case getBiometricDataFailed
  case getKeyFailed(query: Swift.String)
  case readingPublicKeyBytes
  case readingPublicKeyBytesAlert(matchResult: Swift.String)
  case publicKeyCreateFailed
  case decodePemKeyDataFailed
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: PowerFactor.Rabbit.Error, b: PowerFactor.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension PowerFactor.Rabbit : PowerFactor.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension PowerFactor.CS.BigUInt {
  public static func + (a: PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public static func += (a: inout PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt)
}
extension PowerFactor.CS.BigInt {
  public static func + (a: PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func += (a: inout PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt)
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
extension PowerFactor.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : PowerFactor.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Statement {
  @objc deinit
  final public var columnCount: Swift.Int {
    get
    set
  }
  final public var columnNames: [Swift.String] {
    get
    set
  }
  final public var row: PowerFactor.Cursor {
    get
    set
  }
  final public func bind(_ values: (any PowerFactor.Binding)?...) -> PowerFactor.Statement
  final public func bind(_ values: [(any PowerFactor.Binding)?]) -> PowerFactor.Statement
  final public func bind(_ values: [Swift.String : (any PowerFactor.Binding)?]) -> PowerFactor.Statement
  final public func run(_ bindings: (any PowerFactor.Binding)?...) throws -> PowerFactor.Statement
  final public func run(_ bindings: [(any PowerFactor.Binding)?]) throws -> PowerFactor.Statement
  final public func run(_ bindings: [Swift.String : (any PowerFactor.Binding)?]) throws -> PowerFactor.Statement
  final public func scalar(_ bindings: (any PowerFactor.Binding)?...) throws -> (any PowerFactor.Binding)?
  final public func scalar(_ bindings: [(any PowerFactor.Binding)?]) throws -> (any PowerFactor.Binding)?
  final public func scalar(_ bindings: [Swift.String : (any PowerFactor.Binding)?]) throws -> (any PowerFactor.Binding)?
  final public func step() throws -> Swift.Bool
}
extension PowerFactor.Statement : Swift.Sequence {
  final public func makeIterator() -> PowerFactor.Statement
  public typealias Iterator = PowerFactor.Statement
}
extension PowerFactor.Statement : Swift.IteratorProtocol {
  final public func next() -> [(any PowerFactor.Binding)?]?
  public typealias Element = [(any PowerFactor.Binding)?]
}
extension PowerFactor.Statement : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
public struct Cursor {
  public subscript(idx: Swift.Int) -> Swift.Double {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.Int64 {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.String {
    get
  }
  public subscript(idx: Swift.Int) -> PowerFactor.Blob {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.Bool {
    get
  }
  public subscript(idx: Swift.Int) -> Swift.Int {
    get
  }
}
extension PowerFactor.Cursor : Swift.Sequence {
  public subscript(idx: Swift.Int) -> (any PowerFactor.Binding)? {
    get
  }
  public func makeIterator() -> Swift.AnyIterator<(any PowerFactor.Binding)?>
  public typealias Element = (any PowerFactor.Binding)?
  public typealias Iterator = Swift.AnyIterator<(any PowerFactor.Binding)?>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers open class PWFClientResult : PowerFactor.PWFBaseObject, @unchecked Swift.Sendable, Swift.Error {
  @objc open var ErrorCode: Swift.String?
  @objc open var ErrorMessage: Swift.String?
  @objc open var Exception: Swift.String?
  @objc public init(errorCode: Swift.String?, errorMessage: Swift.String?)
  override open func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PWFSoftOtpToken {
  open var Code: Swift.String
  open var RemainSecond: Swift.Int
  open var CurrentProgress: Swift.Int
  @objc deinit
}
extension UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) public func hitTest(pointInGliphRange aPoint: CoreFoundation.CGPoint, event: UIKit.UIEvent?, test: (Swift.Int) -> UIKit.UIView?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) public func pointIsInTextRange(point aPoint: CoreFoundation.CGPoint, range: Foundation.NSRange, padding: UIKit.UIEdgeInsets) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func charIndexForPointInGlyphRect(point aPoint: CoreFoundation.CGPoint) -> Swift.Int?
}
extension UIKit.NSLayoutManager {
  public func characterRangeThatFits(textContainer container: UIKit.NSTextContainer) -> Foundation.NSRange
  public func boundingRectForCharacterRange(range aRange: Foundation.NSRange, inTextContainer container: UIKit.NSTextContainer) -> CoreFoundation.CGRect
}
@usableFromInline
final internal class BlockEncryptor : PowerFactor.Cryptor, PowerFactor.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PowerFactor.Padding, _ worker: any PowerFactor.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension PowerFactor.CS.BigUInt {
  public static func >>= <Other>(lhs: inout PowerFactor.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout PowerFactor.CS.BigUInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: PowerFactor.CS.BigUInt, rhs: Other) -> PowerFactor.CS.BigUInt where Other : Swift.BinaryInteger
  public static func << <Other>(lhs: PowerFactor.CS.BigUInt, rhs: Other) -> PowerFactor.CS.BigUInt where Other : Swift.BinaryInteger
}
extension PowerFactor.CS.BigInt {
  public static func &<< (left: PowerFactor.CS.BigInt, right: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func &<<= (left: inout PowerFactor.CS.BigInt, right: PowerFactor.CS.BigInt)
  public static func &>> (left: PowerFactor.CS.BigInt, right: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func &>>= (left: inout PowerFactor.CS.BigInt, right: PowerFactor.CS.BigInt)
  public static func << <Other>(lhs: PowerFactor.CS.BigInt, rhs: Other) -> PowerFactor.CS.BigInt where Other : Swift.BinaryInteger
  public static func <<= <Other>(lhs: inout PowerFactor.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
  public static func >> <Other>(lhs: PowerFactor.CS.BigInt, rhs: Other) -> PowerFactor.CS.BigInt where Other : Swift.BinaryInteger
  public static func >>= <Other>(lhs: inout PowerFactor.CS.BigInt, rhs: Other) where Other : Swift.BinaryInteger
}
public protocol CipherModeWorker {
  var cipherOperation: PowerFactor.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : PowerFactor.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : PowerFactor.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : PowerFactor.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : PowerFactor.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : PowerFactor.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : PowerFactor.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public class PublicKey : PowerFactor.Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  public static func publicKeys(pemEncoded pemString: Swift.String) -> [PowerFactor.PublicKey]
  @objc deinit
}
public typealias Paddings = Security.SecPadding
public enum SwiftyRSA {
  @available(iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func generateRSAKeyPair(sizeInBits size: Swift.Int) throws -> (privateKey: PowerFactor.PrivateKey, publicKey: PowerFactor.PublicKey)
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PowerFactor.CTR.Error, b: PowerFactor.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PowerFactor.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: PowerFactor.Blowfish.Error, b: PowerFactor.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any PowerFactor.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: PowerFactor.Padding) throws
  @objc deinit
}
extension PowerFactor.Blowfish : PowerFactor.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
extension PowerFactor.CS.BigUInt {
  prefix public static func ~ (a: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public static func |= (a: inout PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt)
  public static func &= (a: inout PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt)
  public static func ^= (a: inout PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt)
}
extension PowerFactor.CS.BigInt {
  prefix public static func ~ (x: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func & (lhs: inout PowerFactor.CS.BigInt, rhs: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func | (lhs: inout PowerFactor.CS.BigInt, rhs: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func ^ (lhs: inout PowerFactor.CS.BigInt, rhs: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func &= (lhs: inout PowerFactor.CS.BigInt, rhs: PowerFactor.CS.BigInt)
  public static func |= (lhs: inout PowerFactor.CS.BigInt, rhs: PowerFactor.CS.BigInt)
  public static func ^= (lhs: inout PowerFactor.CS.BigInt, rhs: PowerFactor.CS.BigInt)
}
public class CheckData {
  public init(tag: Swift.String, data: Swift.String)
  @objc deinit
}
public typealias BigInteger = PowerFactor.CS.BigInt
public typealias BigUInteger = PowerFactor.CS.BigUInt
public enum CS {
}
extension PowerFactor.CS {
  public struct BigUInt : Swift.UnsignedInteger {
    public typealias Word = Swift.UInt
    public init()
    public init(words: [PowerFactor.CS.BigUInt.Word])
    public typealias Magnitude = PowerFactor.CS.BigUInt
  }
}
extension PowerFactor.CS.BigUInt {
  public static var isSigned: Swift.Bool {
    get
  }
  public func signum() -> PowerFactor.CS.BigUInt
}
public struct OFB : PowerFactor.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PowerFactor.OFB.Error, b: PowerFactor.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PowerFactor.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
}
public struct CFB : PowerFactor.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PowerFactor.CFB.Error, b: PowerFactor.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: PowerFactor.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: PowerFactor.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
}
extension PowerFactor.CS.BigUInt {
  public func greatestCommonDivisor(with b: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public func inverse(_ modulus: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt?
}
extension PowerFactor.CS.BigInt {
  public func greatestCommonDivisor(with b: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public func inverse(_ modulus: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt?
}
@_hasMissingDesignatedInitializers open class AppConfig {
  public static func getInstance() -> PowerFactor.AppConfig
  public func initAppConfig(config: PowerFactor.PWFConfig) -> Swift.Bool
  public func getApplicationName() -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PowerFactorContext {
  public static func getInstance() -> PowerFactor.PowerFactorContext
  open func getOwnerKey() -> PowerFactor.TransactionOwnerContract
  @objc deinit
}
public func + (lhs: PowerFactor.Expression<Swift.String>, rhs: PowerFactor.Expression<Swift.String>) -> PowerFactor.Expression<Swift.String>
public func + (lhs: PowerFactor.Expression<Swift.String>, rhs: PowerFactor.Expression<Swift.String?>) -> PowerFactor.Expression<Swift.String?>
public func + (lhs: PowerFactor.Expression<Swift.String?>, rhs: PowerFactor.Expression<Swift.String>) -> PowerFactor.Expression<Swift.String?>
public func + (lhs: PowerFactor.Expression<Swift.String?>, rhs: PowerFactor.Expression<Swift.String?>) -> PowerFactor.Expression<Swift.String?>
public func + (lhs: PowerFactor.Expression<Swift.String>, rhs: Swift.String) -> PowerFactor.Expression<Swift.String>
public func + (lhs: PowerFactor.Expression<Swift.String?>, rhs: Swift.String) -> PowerFactor.Expression<Swift.String?>
public func + (lhs: Swift.String, rhs: PowerFactor.Expression<Swift.String>) -> PowerFactor.Expression<Swift.String>
public func + (lhs: Swift.String, rhs: PowerFactor.Expression<Swift.String?>) -> PowerFactor.Expression<Swift.String?>
public func + <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func + <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func + <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func + <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func + <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func + <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func + <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func + <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func - <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func * <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func / <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
prefix public func - <V>(rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
prefix public func - <V>(rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func % <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func % <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func << <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >> <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func & <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func | <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^ <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
prefix public func ~ <V>(rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value, V.Datatype == Swift.Int64
prefix public func ~ <V>(rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V?> where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func == <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: PowerFactor.Expression<V?>, rhs: V?) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func == <V>(lhs: V?, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: PowerFactor.Expression<V?>, rhs: V?) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func != <V>(lhs: V?, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Equatable
public func > <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func > <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func >= <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func < <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: PowerFactor.Expression<V>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: PowerFactor.Expression<V?>, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: PowerFactor.Expression<V>, rhs: V) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: PowerFactor.Expression<V?>, rhs: V) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: V, rhs: PowerFactor.Expression<V>) -> PowerFactor.Expression<Swift.Bool> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func <= <V>(lhs: V, rhs: PowerFactor.Expression<V?>) -> PowerFactor.Expression<Swift.Bool?> where V : PowerFactor.Value, V.Datatype : Swift.Comparable
public func && (lhs: PowerFactor.Expression<Swift.Bool>, rhs: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool>
public func && (lhs: PowerFactor.Expression<Swift.Bool>, rhs: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?>
public func && (lhs: PowerFactor.Expression<Swift.Bool?>, rhs: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool?>
public func && (lhs: PowerFactor.Expression<Swift.Bool?>, rhs: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?>
public func && (lhs: PowerFactor.Expression<Swift.Bool>, rhs: Swift.Bool) -> PowerFactor.Expression<Swift.Bool>
public func && (lhs: PowerFactor.Expression<Swift.Bool?>, rhs: Swift.Bool) -> PowerFactor.Expression<Swift.Bool?>
public func && (lhs: Swift.Bool, rhs: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool>
public func && (lhs: Swift.Bool, rhs: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?>
public func || (lhs: PowerFactor.Expression<Swift.Bool>, rhs: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool>
public func || (lhs: PowerFactor.Expression<Swift.Bool>, rhs: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?>
public func || (lhs: PowerFactor.Expression<Swift.Bool?>, rhs: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool?>
public func || (lhs: PowerFactor.Expression<Swift.Bool?>, rhs: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?>
public func || (lhs: PowerFactor.Expression<Swift.Bool>, rhs: Swift.Bool) -> PowerFactor.Expression<Swift.Bool>
public func || (lhs: PowerFactor.Expression<Swift.Bool?>, rhs: Swift.Bool) -> PowerFactor.Expression<Swift.Bool?>
public func || (lhs: Swift.Bool, rhs: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool>
public func || (lhs: Swift.Bool, rhs: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?>
prefix public func ! (rhs: PowerFactor.Expression<Swift.Bool>) -> PowerFactor.Expression<Swift.Bool>
prefix public func ! (rhs: PowerFactor.Expression<Swift.Bool?>) -> PowerFactor.Expression<Swift.Bool?>
extension PowerFactor.Module {
  public static func FTS5(_ config: PowerFactor.FTS5Config) -> PowerFactor.Module
}
@_inheritsConvenienceInitializers open class FTS5Config : PowerFactor.FTSConfig {
  public enum Detail : Swift.CustomStringConvertible {
    case full
    case column
    case none
    public var description: Swift.String {
      get
    }
    public static func == (a: PowerFactor.FTS5Config.Detail, b: PowerFactor.FTS5Config.Detail) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init()
  open func contentRowId(_ column: any PowerFactor.Expressible) -> Self
  open func columnSize(_ size: Swift.Int) -> Self
  open func detail(_ detail: PowerFactor.FTS5Config.Detail) -> Self
  @objc deinit
}
extension PowerFactor.CS.BigUInt {
  public func quotientAndRemainder(dividingBy y: PowerFactor.CS.BigUInt) -> (quotient: PowerFactor.CS.BigUInt, remainder: PowerFactor.CS.BigUInt)
  public static func / (x: PowerFactor.CS.BigUInt, y: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public static func % (x: PowerFactor.CS.BigUInt, y: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public static func /= (x: inout PowerFactor.CS.BigUInt, y: PowerFactor.CS.BigUInt)
  public static func %= (x: inout PowerFactor.CS.BigUInt, y: PowerFactor.CS.BigUInt)
}
extension PowerFactor.CS.BigInt {
  public func quotientAndRemainder(dividingBy y: PowerFactor.CS.BigInt) -> (quotient: PowerFactor.CS.BigInt, remainder: PowerFactor.CS.BigInt)
  public static func / (a: PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func % (a: PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public func modulus(_ mod: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
}
extension PowerFactor.CS.BigInt {
  public static func /= (a: inout PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt)
  public static func %= (a: inout PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt)
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: PowerFactor.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: any PowerFactor.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: any PowerFactor.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: any PowerFactor.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
@objc public enum TransactionStatusNames : Swift.Int {
  case rejected = 0, approved = 1, waitingApproval = 2, errorOccured = 3, expired = 4, fraud = 5, canceled = 6
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers open class PWFBaseObject : ObjectiveC.NSObject, Swift.Codable {
  @objc override dynamic public init()
  @objc deinit
  open func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension PowerFactor.PWFBaseObject {
  @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
extension PowerFactor.CS.BigUInt {
  public func power(_ exponent: Swift.Int) -> PowerFactor.CS.BigUInt
  public func power(_ exponent: PowerFactor.CS.BigUInt, modulus: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
}
extension PowerFactor.CS.BigInt {
  public func power(_ exponent: Swift.Int) -> PowerFactor.CS.BigInt
  public func power(_ exponent: PowerFactor.CS.BigInt, modulus: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
}
extension PowerFactor.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: PowerFactor.Padding = .pkcs7) throws
}
precedencegroup ColumnAssignment {
  associativity: left
  assignment: true
  lowerThan: AssignmentPrecedence
}
infix operator <- : ColumnAssignment
public struct Setter {
}
extension PowerFactor.Setter : PowerFactor.Expressible {
  public var expression: PowerFactor.Expression<Swift.Void> {
    get
  }
}
public func <- <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value
public func <- <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value
public func <- <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value
public func <- <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value
public func <- <V>(column: PowerFactor.Expression<V?>, value: V?) -> PowerFactor.Setter where V : PowerFactor.Value
public func += (column: PowerFactor.Expression<Swift.String>, value: PowerFactor.Expression<Swift.String>) -> PowerFactor.Setter
public func += (column: PowerFactor.Expression<Swift.String>, value: Swift.String) -> PowerFactor.Setter
public func += (column: PowerFactor.Expression<Swift.String?>, value: PowerFactor.Expression<Swift.String>) -> PowerFactor.Setter
public func += (column: PowerFactor.Expression<Swift.String?>, value: PowerFactor.Expression<Swift.String?>) -> PowerFactor.Setter
public func += (column: PowerFactor.Expression<Swift.String?>, value: Swift.String) -> PowerFactor.Setter
public func += <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func += <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func += <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func += <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func += <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func -= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func -= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func -= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func -= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func -= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func *= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func *= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func *= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func *= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func *= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func /= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func /= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func /= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func /= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func /= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype : PowerFactor.Number
public func %= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func %= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func %= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func %= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func %= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func <<= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func >>= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func &= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func &= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func &= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func &= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func &= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func |= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func |= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func |= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func |= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func |= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: PowerFactor.Expression<V>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: PowerFactor.Expression<V>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: PowerFactor.Expression<V?>, value: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public func ^= <V>(column: PowerFactor.Expression<V?>, value: V) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
postfix public func ++ <V>(column: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
postfix public func ++ <V>(column: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
postfix public func -- <V>(column: PowerFactor.Expression<V>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
postfix public func -- <V>(column: PowerFactor.Expression<V?>) -> PowerFactor.Setter where V : PowerFactor.Value, V.Datatype == Swift.Int64
public class PWFTransactionOptions {
  public init(isDarkMode: Swift.Bool = false, isEnableManualScreenOffMode: Swift.Bool = false, securityCheckDataList: [PowerFactor.CheckData] = [])
  @objc deinit
}
extension PowerFactor.RSA : PowerFactor.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.encrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func encrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: PowerFactor.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Prepare the data for the specified variant
    let preparedData = try variant.prepare(bytes, blockSize: self.keySizeBytes)

    // Encrypt the prepared data
    return try variant.formatEncryptedBytes(self.encryptPreparedBytes(preparedData), blockSize: self.keySizeBytes)
  }
  @inlinable final internal func encryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Calculate encrypted data
    return BigUInteger(Data(bytes)).power(self.e, modulus: self.n).serialize().bytes
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    return try self.decrypt(Array<UInt8>(bytes), variant: .pksc1v15)
  }
  @inlinable final public func decrypt(_ bytes: Swift.Array<Swift.UInt8>, variant: PowerFactor.RSA.RSAEncryptionVariant) throws -> Swift.Array<Swift.UInt8> {
    // Decrypt the data
    let decrypted = try self.decryptPreparedBytes(bytes)

    // Remove padding / unstructure data and return the raw plaintext
    return variant.removePadding(decrypted, blockSize: self.keySizeBytes)
  }
  @inlinable final internal func decryptPreparedBytes(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    // Check for Private Exponent presence
    guard let d = d else { throw RSA.Error.noPrivateKey }

    // Calculate decrypted data
    return BigUInteger(Data(bytes)).power(d, modulus: self.n).serialize().bytes
  }
}
extension PowerFactor.RSA {
  public enum RSAEncryptionVariant {
    case unsafe
    case raw
    case pksc1v15
    @inlinable internal func prepare(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) throws -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          // We need at least 11 bytes of padding in order to safely encrypt messages
          // - block types 1 and 2 have this minimum padding requirement, block type 0 isn't specified, but we enforce the minimum padding length here to be safe.
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Array(repeating: 0x00, count: blockSize - bytes.count) + bytes
        case .pksc1v15:
          // The `Security` framework refuses to encrypt a zero byte message using the pkcs1v15 padding scheme, so we do the same
          guard !bytes.isEmpty else { throw RSA.Error.invalidMessageLengthForEncryption }
          // We need at least 11 bytes of random padding in order to safely encrypt messages (RFC2313 Section 8.1 - Note 6)
          guard blockSize >= bytes.count + 11 else { throw RSA.Error.invalidMessageLengthForEncryption }
          return Padding.eme_pkcs1v15.add(to: bytes, blockSize: blockSize)
      @unknown default:
        assertionFailure()
        return [UInt8](repeating: UInt8.random(in: 0..<UInt8.max), count: bytes.count)
      }
    }
    @inlinable internal func formatEncryptedBytes(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw, .pksc1v15:
          // Format the encrypted bytes before returning
          return Array<UInt8>(repeating: 0x00, count: blockSize - bytes.count) + bytes
      @unknown default:
        assertionFailure()
        return [UInt8](repeating: UInt8.random(in: 0..<UInt8.max), count: bytes.count)
      }
    }
    @inlinable internal func removePadding(_ bytes: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8> {
      switch self {
        case .unsafe:
          return bytes
        case .raw:
          return bytes
        case .pksc1v15:
          // Convert the Octet String into an Integer Primitive using the BigInteger `serialize` method
          // (this effectively just prefixes the data with a 0x00 byte indicating that its a positive integer)
          return Padding.eme_pkcs1v15.remove(from: [0x00] + bytes, blockSize: blockSize)
      @unknown default:
        assertionFailure()
        return [UInt8](repeating: UInt8.random(in: 0..<UInt8.max), count: bytes.count)
      }
    }
    public static func == (a: PowerFactor.RSA.RSAEncryptionVariant, b: PowerFactor.RSA.RSAEncryptionVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension PowerFactor.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: PowerFactor.Padding = .pkcs7) throws
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
  @inlinable internal subscript(safe index: Swift.Array<Element>.Index) -> Element? {
    get {
    return indices.contains(index) ? self[index] : nil
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: PowerFactor.SHA2.Variant) -> [Element]
  public func sha3(_ variant: PowerFactor.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: any PowerFactor.Cipher) throws -> [Element]
  public func decrypt(cipher: any PowerFactor.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : PowerFactor.Authenticator
}
public enum SignatureError : Swift.Error {
  case sign
  case verify
  public static func == (a: PowerFactor.SignatureError, b: PowerFactor.SignatureError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CryptoSwiftSignature : AnyObject {
  var keySize: Swift.Int { get }
  func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
extension PowerFactor.CryptoSwiftSignature {
  public func sign(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func verify(signature: Swift.Array<Swift.UInt8>, for expectedData: Swift.Array<Swift.UInt8>) throws -> Swift.Bool
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
@_inheritsConvenienceInitializers @objc open class PowerFactorMethods : ObjectiveC.NSObject {
  public static let screenMirroringDidChangeNotification: Foundation.NSNotification.Name
  public func Init(config: PowerFactor.PWFConfig, onInitializationSuccess: @escaping (Swift.Bool) -> Swift.Void, onInitializationFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void, watchDelegate: (any PowerFactor.PWFWatchDelegate)? = nil)
  public static func securityCheck() -> Swift.Bool
  public static func getWatchActivationData() throws -> Swift.String?
  @available(iOS 9.0, *)
  public static func activateWatch(onActivationSuccess: @escaping () -> Swift.Void, onActivationFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 9.0, *)
  public static func deActivateWatch(onDeactivationSuccess: @escaping () -> Swift.Void, onDeactivationFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 9.0, *)
  public static func checkWatchStatus(onCheckStatusCompleted: @escaping (Swift.Bool) -> Swift.Void, onCheckStatusFailed: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func activateDevice(_ otp: Swift.String, customerId: Swift.Int64, pin: Swift.String, onActivationSuccess: @escaping (_ _activationData: PowerFactor.PWFActivationResponse) -> Swift.Void, onActivationFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func activateDeviceWithSE(_ otp: Swift.String, customerId: Swift.Int64, pin: Swift.String, onActivationSuccess: @escaping (_ _activationData: PowerFactor.PWFActivationResponse) -> Swift.Void, onActivationFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func login(_ customerId: Swift.Int64, pin: Swift.String, onLoginSuccess: @escaping (_ loginData: PowerFactor.PWFLoginResponse) -> Swift.Void, onLoginFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 9.0, *)
  public static func loginWithBiometry(localizedReason: Swift.String, customerId: Swift.Int64, onLoginSuccess: @escaping (_ loginData: PowerFactor.PWFLoginResponse) -> Swift.Void, onAuthenticationSuccess: @escaping () -> Swift.Void, onLoginFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 9.0, *)
  public static func activateBiometry(localizedReason: Swift.String, onActivationSuccess: @escaping () -> Swift.Void, onAuthenticationSuccess: @escaping () -> Swift.Void, onActivationFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 9.0, *)
  public static func deactivateBiometry(onDeactivationSuccess: @escaping () -> Swift.Void, onDeactivationFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 9.0, *)
  public static func isBiometryEnable(user: PowerFactor.PWFUserContract? = nil) throws -> Swift.Bool
  @available(iOS 10.0, *)
  public static func getOneTouchTransaction(config: PowerFactor.PWFConfig, transactionToken: Swift.String, customerId: Swift.Int64, _ onTransactionBegin: @escaping (_ data: PowerFactor.PWFTransactionContract) -> Swift.Void, onTransactionFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void = { (error: [PWFClientResult]) in })
  @available(iOS 10.0, *)
  public static func getOneTouchTransactionWithScreen(vc: UIKit.UIViewController, config: PowerFactor.PWFConfig, transactionToken: Swift.String, customerId: Swift.Int64, options: PowerFactor.PWFTransactionOptions? = nil, onTransactionBegin: @escaping (_ data: PowerFactor.PWFTransactionContract) -> Swift.Void, onClickButton: @escaping (_ name: PowerFactor.TransactionStatusNames) -> Swift.Void, onTransactionCompleted: @escaping () -> Swift.Void, onTransactionFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void = { (error: [PWFClientResult]) in })
  public static func dismissTransactionScreen(isForce: Swift.Bool = false) -> Swift.Bool
  @available(iOS 10.0, *)
  public static func beginTransactionWithScreen(vc: UIKit.UIViewController, options: PowerFactor.PWFTransactionOptions? = nil, _ onTransactionBegin: @escaping (_ data: PowerFactor.PWFTransactionContract) -> Swift.Void, _ onClickButton: @escaping (_ name: PowerFactor.TransactionStatusNames) -> Swift.Void, _ onClickActionBarButton: @escaping (_ iconName: Swift.String) -> Swift.Void, onTransactionCompleted: @escaping () -> Swift.Void, onTransactionFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void = { (error: [PWFClientResult]) in }) -> Swift.String
  @available(iOS 10.0, *)
  public static func cancelBeginTransaction()
  @available(iOS 10.0, *)
  public static func beginTransaction(_ onTransactionBegin: @escaping (_ data: PowerFactor.PWFTransactionContract) -> Swift.Void, onTransactionFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void = { (error: [PWFClientResult]) in }) -> Swift.String
  @available(iOS 10.0, *)
  public static func completeClientTransaction(_ status: PowerFactor.TransactionStatusNames, onTransactionCompleted: @escaping () -> Swift.Void, onTransactionFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completeClientTransaction(status: PowerFactor.TransactionStatusNames, pin: Swift.String, onTransactionCompleted: @escaping () -> Swift.Void, onTransactionFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completeClientTransaction(status: PowerFactor.TransactionStatusNames, localizedReason: Swift.String, onAuthenticationSuccess: @escaping () -> Swift.Void, onTransactionCompleted: @escaping () -> Swift.Void, onTransactionFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func getMobileApprovalList(_ onSuccess: @escaping ([PowerFactor.PWFTransactionContract]) -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completeMobileApproval(_ transactionId: Swift.String, status: PowerFactor.TransactionStatusNames, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completeMobileApproval(pin: Swift.String, transactionId: Swift.String, status: PowerFactor.TransactionStatusNames, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completeMobileApproval(localizedReason: Swift.String, transactionId: Swift.String, status: PowerFactor.TransactionStatusNames, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void, onAuthenticationSuccess: @escaping () -> Swift.Void)
  public static func getUserList() throws -> [PowerFactor.PWFUserContract]?
  public static func getSyncUserList(onSuccess: @escaping (_ userList: [PowerFactor.PWFUserContract]) -> Swift.Void, onFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  public static func deleteUser(_ customerId: Swift.Int64) throws -> Swift.Bool
  public static func deleteAllUsers()
  @available(iOS 10.0, *)
  public static func changePIN(_ customerId: Swift.Int64, pin: Swift.String, newPIN: Swift.String, onPINChanged: @escaping () -> Swift.Void, onPINChangeFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  public static func logout(_ logoutSuccess: @escaping () -> Swift.Void = { })
  public static func completeQRTransaction(qrContent: Swift.String, onQRApproved: @escaping (_ data: PowerFactor.ApproveQRTransactionResponse) -> Swift.Void, onQRApproveFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  public static func approveQRVerificationCode(qrContent: Swift.String, secondaryVerificationCode: Swift.String, onVerificationCodeApproved: @escaping (_ data: PowerFactor.ApproveQRTransactionResponse) -> Swift.Void, onFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  public static func rejectQRVerificationCode(qrContent: Swift.String, secondaryVerificationCode: Swift.String, onRejected: @escaping (_ data: PowerFactor.ApproveQRTransactionResponse) -> Swift.Void, onFailure: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completePushTransaction(config: PowerFactor.PWFConfig, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completePushTransactions(config: PowerFactor.PWFConfig, pin: Swift.String, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completePushTransaction(config: PowerFactor.PWFConfig, pin: Swift.String, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completePushTransaction(config: PowerFactor.PWFConfig, localizedReason: Swift.String, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onAuthenticationSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func rejectPushTransaction(config: PowerFactor.PWFConfig, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func cancelPushTransaction(config: PowerFactor.PWFConfig, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func completeSmartWatchTransaction(config: PowerFactor.PWFConfig, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  @available(iOS 10.0, *)
  public static func rejectSmartWatchTransaction(config: PowerFactor.PWFConfig, token: Swift.String, customerId: Swift.Int64, onSuccess: @escaping () -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  public static func softOtpInitialization(onActive: @escaping (_ isActive: Swift.Bool) -> Swift.Void, onCallback: @escaping (_ token: PowerFactor.PWFSoftOtpToken) -> Swift.Void, onError: @escaping ([PowerFactor.PWFClientResult]) -> Swift.Void)
  public static func stopSoftOtpGeneration()
  public static func isJailBroken() -> Swift.Bool
  public static func getOwnerKey() -> Swift.String?
  public func StartCheckScreenMirroring()
  public static func getSDKVersion() -> Swift.String
  public static func TransactionScreenTest(vc: UIKit.UIViewController, transactionContent: Swift.String?, options: PowerFactor.PWFTransactionOptions? = nil)
  @objc override dynamic public init()
  @objc deinit
}
@objc final public class OTP : ObjectiveC.NSObject {
  final public let account: Swift.String
  final public var err: Swift.String
  public init?(urlc: Foundation.URLComponents)
  @objc required public init?(coder aDecoder: Foundation.NSCoder)
  @objc final public func encode(with aCoder: Foundation.NSCoder)
  final public func code(_ counter: Swift.Int64) -> Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers open class SwKeyStore {
  public enum SecError : Darwin.OSStatus, Swift.Error {
    case unimplemented
    case param
    case allocate
    case notAvailable
    case authFailed
    case duplicateItem
    case itemNotFound
    case interactionNotAllowed
    case decode
    case missingEntitlement
    public static var debugLevel: Swift.Int
    public init?(rawValue: Darwin.OSStatus)
    public typealias RawValue = Darwin.OSStatus
    public var rawValue: Darwin.OSStatus {
      get
    }
  }
  public static func getKey(_ keyTag: Swift.String) throws -> Swift.String
  public static func delKey(_ keyTag: Swift.String) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers open class SwKeyConvert {
  public enum SwError : Swift.Error {
    case invalidKey
    case badPassphrase
    case keyNotEncrypted
    public static var debugLevel: Swift.Int
    public static func == (a: PowerFactor.SwKeyConvert.SwError, b: PowerFactor.SwKeyConvert.SwError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
    public typealias EncMode = PowerFactor.PEM.EncryptedPrivateKey.EncMode
    public static func encryptPEM(_ pemKey: Swift.String, passphrase: Swift.String, mode: PowerFactor.SwKeyConvert.PrivateKey.EncMode) throws -> Swift.String
    public static func decryptPEM(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
    public static func derToPKCS8PEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PKCS8 {
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
    public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
    public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func addHeader(_ derKey: Foundation.Data) -> Foundation.Data
    public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
    public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
    public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PEM {
  public enum SwError : Swift.Error {
    case parse(Swift.String)
    case badPassphrase
    case keyNotEncrypted
    public static var debugLevel: Swift.Int
  }
  @_hasMissingDesignatedInitializers open class PrivateKey {
    public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class PublicKey {
    public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class EncryptedPrivateKey {
    public enum EncMode {
      case aes128CBC, aes256CBC
      public static func == (a: PowerFactor.PEM.EncryptedPrivateKey.EncMode, b: PowerFactor.PEM.EncryptedPrivateKey.EncMode) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public static func toDER(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Foundation.Data
    public static func toPEM(_ derKey: Foundation.Data, passphrase: Swift.String, mode: PowerFactor.PEM.EncryptedPrivateKey.EncMode) -> Swift.String
    @objc deinit
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class CC {
  public typealias CCCryptorStatus = Swift.Int32
  public enum CCError : PowerFactor.CC.CCCryptorStatus, Swift.Error {
    case paramError
    case bufferTooSmall
    case memoryFailure
    case alignmentError
    case decodeError
    case unimplemented
    case overflow
    case rngFailure
    public static var debugLevel: Swift.Int
    public init?(rawValue: PowerFactor.CC.CCCryptorStatus)
    public typealias RawValue = PowerFactor.CC.CCCryptorStatus
    public var rawValue: PowerFactor.CC.CCCryptorStatus {
      get
    }
  }
  public static func generateRandom(_ size: Swift.Int) -> Foundation.Data
  public typealias CCDigestAlgorithm = Swift.UInt32
  public enum DigestAlgorithm : PowerFactor.CC.CCDigestAlgorithm {
    case none
    case md5
    case rmd128, rmd160, rmd256, rmd320
    case sha1
    case sha224, sha256, sha384, sha512
    public init?(rawValue: PowerFactor.CC.CCDigestAlgorithm)
    public typealias RawValue = PowerFactor.CC.CCDigestAlgorithm
    public var rawValue: PowerFactor.CC.CCDigestAlgorithm {
      get
    }
  }
  public static func digest(_ data: Foundation.Data, alg: PowerFactor.CC.DigestAlgorithm) -> Foundation.Data
  public typealias CCHmacAlgorithm = Swift.UInt32
  public enum HMACAlg : PowerFactor.CC.CCHmacAlgorithm {
    case sha1, md5, sha256, sha384, sha512, sha224
    public init?(rawValue: PowerFactor.CC.CCHmacAlgorithm)
    public typealias RawValue = PowerFactor.CC.CCHmacAlgorithm
    public var rawValue: PowerFactor.CC.CCHmacAlgorithm {
      get
    }
  }
  public static func HMAC(_ data: Foundation.Data, alg: PowerFactor.CC.HMACAlg, key: Foundation.Data) -> Foundation.Data
  public typealias CCOperation = Swift.UInt32
  public enum OpMode : PowerFactor.CC.CCOperation {
    case encrypt, decrypt
    public init?(rawValue: PowerFactor.CC.CCOperation)
    public typealias RawValue = PowerFactor.CC.CCOperation
    public var rawValue: PowerFactor.CC.CCOperation {
      get
    }
  }
  public typealias CCMode = Swift.UInt32
  public enum BlockMode : PowerFactor.CC.CCMode {
    case ecb, cbc, cfb, ctr, f8, lrw, ofb, xts, rc4, cfb8
    public init?(rawValue: PowerFactor.CC.CCMode)
    public typealias RawValue = PowerFactor.CC.CCMode
    public var rawValue: PowerFactor.CC.CCMode {
      get
    }
  }
  public enum AuthBlockMode : PowerFactor.CC.CCMode {
    case gcm, ccm
    public init?(rawValue: PowerFactor.CC.CCMode)
    public typealias RawValue = PowerFactor.CC.CCMode
    public var rawValue: PowerFactor.CC.CCMode {
      get
    }
  }
  public typealias CCAlgorithm = Swift.UInt32
  public enum Algorithm : PowerFactor.CC.CCAlgorithm {
    case aes, des, threeDES, cast, rc4, rc2, blowfish
    public init?(rawValue: PowerFactor.CC.CCAlgorithm)
    public typealias RawValue = PowerFactor.CC.CCAlgorithm
    public var rawValue: PowerFactor.CC.CCAlgorithm {
      get
    }
  }
  public typealias CCPadding = Swift.UInt32
  public enum Padding : PowerFactor.CC.CCPadding {
    case noPadding, pkcs7Padding
    public init?(rawValue: PowerFactor.CC.CCPadding)
    public typealias RawValue = PowerFactor.CC.CCPadding
    public var rawValue: PowerFactor.CC.CCPadding {
      get
    }
  }
  public static func crypt(_ opMode: PowerFactor.CC.OpMode, blockMode: PowerFactor.CC.BlockMode, algorithm: PowerFactor.CC.Algorithm, padding: PowerFactor.CC.Padding, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  public static func cryptAuth(_ opMode: PowerFactor.CC.OpMode, blockMode: PowerFactor.CC.AuthBlockMode, algorithm: PowerFactor.CC.Algorithm, data: Foundation.Data, aData: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, tagLength: Swift.Int) throws -> Foundation.Data
  public static func digestAvailable() -> Swift.Bool
  public static func randomAvailable() -> Swift.Bool
  public static func hmacAvailable() -> Swift.Bool
  public static func cryptorAvailable() -> Swift.Bool
  public static func available() -> Swift.Bool
  @_hasMissingDesignatedInitializers open class GCM {
    public static func crypt(_ opMode: PowerFactor.CC.OpMode, algorithm: PowerFactor.CC.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CCM {
    public static func crypt(_ opMode: PowerFactor.CC.OpMode, algorithm: PowerFactor.CC.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class RSA {
    public typealias CCAsymmetricPadding = Swift.UInt32
    public enum AsymmetricPadding : PowerFactor.CC.RSA.CCAsymmetricPadding {
      case pkcs1
      case oaep
      public init?(rawValue: PowerFactor.CC.RSA.CCAsymmetricPadding)
      public typealias RawValue = PowerFactor.CC.RSA.CCAsymmetricPadding
      public var rawValue: PowerFactor.CC.RSA.CCAsymmetricPadding {
        get
      }
    }
    public enum AsymmetricSAPadding : Swift.UInt32 {
      case pkcs15
      case pss
      public init?(rawValue: Swift.UInt32)
      public typealias RawValue = Swift.UInt32
      public var rawValue: Swift.UInt32 {
        get
      }
    }
    public static func generateKeyPair(_ keySize: Swift.Int = 4096) throws -> (Foundation.Data, Foundation.Data)
    public static func encrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: PowerFactor.CC.RSA.AsymmetricPadding, digest: PowerFactor.CC.DigestAlgorithm) throws -> Foundation.Data
    public static func decrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: PowerFactor.CC.RSA.AsymmetricPadding, digest: PowerFactor.CC.DigestAlgorithm) throws -> (Foundation.Data, Swift.Int)
    public static func sign(_ message: Foundation.Data, derKey: Foundation.Data, padding: PowerFactor.CC.RSA.AsymmetricSAPadding, digest: PowerFactor.CC.DigestAlgorithm, saltLen: Swift.Int) throws -> Foundation.Data
    public static func verify(_ message: Foundation.Data, derKey: Foundation.Data, padding: PowerFactor.CC.RSA.AsymmetricSAPadding, digest: PowerFactor.CC.DigestAlgorithm, saltLen: Swift.Int, signedData: Foundation.Data) throws -> Swift.Bool
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class DH {
    public enum DHParam {
      case rfc3526Group5
      public static func == (a: PowerFactor.CC.DH.DHParam, b: PowerFactor.CC.DH.DHParam) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    open class DH {
      public init(dhParam: PowerFactor.CC.DH.DHParam) throws
      open func generateKey() throws -> Foundation.Data
      open func computeKey(_ peerKey: Foundation.Data) throws -> Foundation.Data
      @objc deinit
    }
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class EC {
    public static func generateKeyPair(_ keySize: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
    public static func signHash(_ privateKey: Foundation.Data, hash: Foundation.Data) throws -> Foundation.Data
    public static func verifyHash(_ publicKey: Foundation.Data, hash: Foundation.Data, signedData: Foundation.Data) throws -> Swift.Bool
    public static func computeSharedSecret(_ privateKey: Foundation.Data, publicKey: Foundation.Data) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CRC {
    public typealias CNcrc = Swift.UInt32
    public enum Mode : PowerFactor.CC.CRC.CNcrc {
      case crc8, crc8ICODE, crc8ITU, crc8ROHC, crc8WCDMA, crc16, crc16CCITTTrue, crc16CCITTFalse, crc16USB, crc16XMODEM, crc16DECTR, crc16DECTX, crc16ICODE, crc16VERIFONE, crc16A, crc16B, crc16Fletcher, crc32Adler, crc32, crc32CASTAGNOLI, crc32BZIP2, crc32MPEG2, crc32POSIX, crc32XFER, crc64ECMA182
      public init?(rawValue: PowerFactor.CC.CRC.CNcrc)
      public typealias RawValue = PowerFactor.CC.CRC.CNcrc
      public var rawValue: PowerFactor.CC.CRC.CNcrc {
        get
      }
    }
    public static func crc(_ input: Foundation.Data, mode: PowerFactor.CC.CRC.Mode) throws -> Swift.UInt64
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class CMAC {
    public static func AESCMAC(_ data: Foundation.Data, key: Foundation.Data) -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class KeyDerivation {
    public typealias CCPseudoRandomAlgorithm = Swift.UInt32
    public enum PRFAlg : PowerFactor.CC.KeyDerivation.CCPseudoRandomAlgorithm {
      case sha1, sha224, sha256, sha384, sha512
      public init?(rawValue: PowerFactor.CC.KeyDerivation.CCPseudoRandomAlgorithm)
      public typealias RawValue = PowerFactor.CC.KeyDerivation.CCPseudoRandomAlgorithm
      public var rawValue: PowerFactor.CC.KeyDerivation.CCPseudoRandomAlgorithm {
        get
      }
    }
    public static func PBKDF2(_ password: Swift.String, salt: Foundation.Data, prf: PowerFactor.CC.KeyDerivation.PRFAlg, rounds: Swift.UInt32) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @_hasMissingDesignatedInitializers open class KeyWrap {
    public static let rfc3394IV: Foundation.Data
    public static func SymmetricKeyWrap(_ iv: Foundation.Data, kek: Foundation.Data, rawKey: Foundation.Data) throws -> Foundation.Data
    public static func SymmetricKeyUnwrap(_ iv: Foundation.Data, kek: Foundation.Data, wrappedKey: Foundation.Data) throws -> Foundation.Data
    public static func available() -> Swift.Bool
    @objc deinit
  }
  @objc deinit
}
extension Foundation.Data {
  public func hexadecimalString() -> Swift.String
  public func arrayOfBytes() -> [Swift.UInt8]
}
extension Swift.String {
  public func dataFromHexadecimalString() -> Foundation.Data?
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
extension PowerFactor.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
}
extension PowerFactor.CS.BigInt {
  public init()
  public init(_ integer: PowerFactor.CS.BigUInt)
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
}
extension PowerFactor.CS.BigUInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.UInt64)
  public typealias IntegerLiteralType = Swift.UInt64
}
extension PowerFactor.CS.BigInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int64)
  public typealias IntegerLiteralType = Swift.Int64
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: PowerFactor.BlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: PowerFactor.BlockModeOption
  @usableFromInline
  internal static let paddingRequired: PowerFactor.BlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: PowerFactor.BlockModeOption
  public typealias ArrayLiteralElement = PowerFactor.BlockModeOption
  public typealias Element = PowerFactor.BlockModeOption
  public typealias RawValue = Swift.Int
}
public enum PKCS5 {
}
final public class OCB : PowerFactor.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: PowerFactor.OCB.Mode, b: PowerFactor.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: PowerFactor.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: PowerFactor.OCB.Error, b: PowerFactor.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: PowerFactor.OCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: PowerFactor.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
  @objc deinit
}
public enum KeychainItemAccessibility {
  @available(iOS 4, *)
  case afterFirstUnlock
  @available(iOS 4, *)
  case afterFirstUnlockThisDeviceOnly
  @available(iOS 4, *)
  case always
  @available(iOS 8, *)
  case whenPasscodeSetThisDeviceOnly
  @available(iOS 4, *)
  case alwaysThisDeviceOnly
  @available(iOS 4, *)
  case whenUnlocked
  @available(iOS 4, *)
  case whenUnlockedThisDeviceOnly
  public static func == (a: PowerFactor.KeychainItemAccessibility, b: PowerFactor.KeychainItemAccessibility) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension PowerFactor.CS.BigUInt : Swift.Comparable {
  public static func compare(_ a: PowerFactor.CS.BigUInt, _ b: PowerFactor.CS.BigUInt) -> Foundation.ComparisonResult
  public static func == (a: PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt) -> Swift.Bool
  public static func < (a: PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt) -> Swift.Bool
}
extension PowerFactor.CS.BigInt {
  public static func == (a: PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt) -> Swift.Bool
  public static func < (a: PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt) -> Swift.Bool
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension PowerFactor.CS.BigUInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension PowerFactor.CS.BigInt : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Poly1305 : PowerFactor.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: PowerFactor.Poly1305.Error, b: PowerFactor.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension PowerFactor.RSA : PowerFactor.CryptoSwiftSignature {
  final public func sign(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func sign(_ bytes: Swift.Array<Swift.UInt8>, variant: PowerFactor.RSA.SignatureVariant) throws -> Swift.Array<Swift.UInt8>
  final public func verify(signature: Swift.ArraySlice<Swift.UInt8>, for expectedData: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Bool
  final public func verify(signature: Swift.Array<Swift.UInt8>, for bytes: Swift.Array<Swift.UInt8>, variant: PowerFactor.RSA.SignatureVariant) throws -> Swift.Bool
}
extension PowerFactor.RSA {
  public enum SignatureVariant {
    case raw
    case message_pkcs1v15_MD5
    case message_pkcs1v15_SHA1
    case message_pkcs1v15_SHA224
    case message_pkcs1v15_SHA256
    case message_pkcs1v15_SHA384
    case message_pkcs1v15_SHA512
    case message_pkcs1v15_SHA512_224
    case message_pkcs1v15_SHA512_256
    case digest_pkcs1v15_RAW
    case digest_pkcs1v15_MD5
    case digest_pkcs1v15_SHA1
    case digest_pkcs1v15_SHA224
    case digest_pkcs1v15_SHA256
    case digest_pkcs1v15_SHA384
    case digest_pkcs1v15_SHA512
    case digest_pkcs1v15_SHA512_224
    case digest_pkcs1v15_SHA512_256
    public static func == (a: PowerFactor.RSA.SignatureVariant, b: PowerFactor.RSA.SignatureVariant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension Swift.String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: PowerFactor.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: any PowerFactor.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: any PowerFactor.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : PowerFactor.Authenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
@available(*, renamed: "Digest")
public typealias Hash = PowerFactor.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: PowerFactor.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: PowerFactor.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
extension Swift.String {
  public func decryptBase64ToString(cipher: any PowerFactor.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: any PowerFactor.Cipher) throws -> Swift.Array<Swift.UInt8>
}
extension Dispatch.DispatchQueue {
  public class func once(token: Swift.String, block: () -> Swift.Void)
}
public typealias Star = (PowerFactor.Expression<any PowerFactor.Binding>?, PowerFactor.Expression<any PowerFactor.Binding>?) -> PowerFactor.Expression<Swift.Void>
public func * (_: PowerFactor.Expression<any PowerFactor.Binding>?, _: PowerFactor.Expression<any PowerFactor.Binding>?) -> PowerFactor.Expression<Swift.Void>
public protocol _OptionalType {
  associatedtype WrappedType
}
extension Swift.Optional : PowerFactor._OptionalType {
  public typealias WrappedType = Wrapped
}
extension PowerFactor.CS.BigInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension PowerFactor.CS.BigUInt : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum ECCError : Swift.Error {
  case keyGenerationFailed(error: CoreFoundation.CFError?)
  case keyCopyFailed(status: Darwin.OSStatus)
  case tagEncodingFailed
  case signatureAlgorithmNotSupport
  case signatureCreateFailed(error: CoreFoundation.CFError?)
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
  case ecdhFaield(error: CoreFoundation.CFError?)
  case decryptionFaield
}
open class KeychainWrapper {
  @available(*, deprecated, message: "KeychainWrapper.defaultKeychainWrapper is deprecated 2.2.1, use KeychainWrapper.standard instead")
  public static let defaultKeychainWrapper: PowerFactor.KeychainWrapper
  public static let standard: PowerFactor.KeychainWrapper
  public var serviceName: Swift.String {
    get
  }
  public var accessGroup: Swift.String? {
    get
  }
  public init(serviceName: Swift.String, accessGroup: Swift.String? = nil)
  open func hasValue(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  open func accessibilityOfKey(_ key: Swift.String) -> PowerFactor.KeychainItemAccessibility?
  open func allKeys() -> Swift.Set<Swift.String>
  open func integer(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Int?
  open func float(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Float?
  open func double(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Double?
  open func bool(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool?
  open func string(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.String?
  open func object(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> (any Foundation.NSCoding)?
  open func data(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Foundation.Data?
  open func dataRef(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Foundation.Data?
  @discardableResult
  open func set(_ value: Swift.Int, forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Float, forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Double, forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.Bool, forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Swift.String, forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: any Foundation.NSCoding, forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @discardableResult
  open func set(_ value: Foundation.Data, forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @available(*, deprecated, message: "remove is deprecated 2.2.1, use removeObject instead")
  @discardableResult
  open func remove(key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  @discardableResult
  open func removeObject(forKey key: Swift.String, withAccessibility accessibility: PowerFactor.KeychainItemAccessibility? = nil) -> Swift.Bool
  open func removeAllKeys() -> Swift.Bool
  open class func wipeKeychain()
  @objc deinit
}
extension PowerFactor.CS.BigUInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension PowerFactor.CS.BigInt {
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
}
extension Swift.BinaryFloatingPoint where Self.RawExponent : Swift.FixedWidthInteger, Self.RawSignificand : Swift.FixedWidthInteger {
  public init(_ value: PowerFactor.CS.BigInt)
  public init(_ value: PowerFactor.CS.BigUInt)
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension PowerFactor.Bit {
  @inlinable internal func inverted() -> PowerFactor.Bit {
    self == .zero ? .one : .zero
  }
}
extension PowerFactor.SchemaType {
  public func drop(ifExists: Swift.Bool = false) -> Swift.String
}
extension PowerFactor.Table {
  public func create(temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false, block: (PowerFactor.TableBuilder) -> Swift.Void) -> Swift.String
  public func create(_ query: any PowerFactor.QueryType, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false) -> Swift.String
  public func addColumn<V>(_ name: PowerFactor.Expression<V>, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V) -> Swift.String where V : PowerFactor.Value
  public func addColumn<V>(_ name: PowerFactor.Expression<V>, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V) -> Swift.String where V : PowerFactor.Value
  public func addColumn<V>(_ name: PowerFactor.Expression<V?>, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V? = nil) -> Swift.String where V : PowerFactor.Value
  public func addColumn<V>(_ name: PowerFactor.Expression<V?>, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V? = nil) -> Swift.String where V : PowerFactor.Value
  public func addColumn<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.Int64
  public func addColumn<V>(_ name: PowerFactor.Expression<V>, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V, collate: PowerFactor.Collation) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.String
  public func addColumn<V>(_ name: PowerFactor.Expression<V>, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V, collate: PowerFactor.Collation) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.String
  public func addColumn<V>(_ name: PowerFactor.Expression<V?>, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V? = nil, collate: PowerFactor.Collation) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.String
  public func addColumn<V>(_ name: PowerFactor.Expression<V?>, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V? = nil, collate: PowerFactor.Collation) -> Swift.String where V : PowerFactor.Value, V.Datatype == Swift.String
  public func rename(_ to: PowerFactor.Table) -> Swift.String
  public func createIndex(_ columns: any PowerFactor.Expressible...) -> Swift.String
  public func createIndex(_ columns: [any PowerFactor.Expressible], unique: Swift.Bool = false, ifNotExists: Swift.Bool = false) -> Swift.String
  public func dropIndex(_ columns: any PowerFactor.Expressible...) -> Swift.String
  public func dropIndex(_ columns: [any PowerFactor.Expressible], ifExists: Swift.Bool = false) -> Swift.String
}
extension PowerFactor.View {
  public func create(_ query: any PowerFactor.QueryType, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false) -> Swift.String
  public func drop(ifExists: Swift.Bool = false) -> Swift.String
}
extension PowerFactor.VirtualTable {
  public func create(_ using: PowerFactor.Module, ifNotExists: Swift.Bool = false) -> Swift.String
  public func rename(_ to: PowerFactor.VirtualTable) -> Swift.String
}
@_hasMissingDesignatedInitializers final public class TableBuilder {
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: PowerFactor.Expression<V>? = nil) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: PowerFactor.Expression<V>? = nil) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: PowerFactor.Expression<V>? = nil) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: PowerFactor.Expression<V?>) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: PowerFactor.Expression<V>? = nil) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: PowerFactor.Expression<V?>) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V>, primaryKey: Swift.Bool, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: PowerFactor.Expression<V>? = nil) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V>, primaryKey: Swift.Bool, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: PowerFactor.Expression<V>? = nil) where V : PowerFactor.Value
  final public func column<V>(_ name: PowerFactor.Expression<V>, primaryKey: PowerFactor.PrimaryKey, check: PowerFactor.Expression<Swift.Bool>? = nil) where V : PowerFactor.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: PowerFactor.Expression<V>, primaryKey: PowerFactor.PrimaryKey, check: PowerFactor.Expression<Swift.Bool?>) where V : PowerFactor.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) where V : PowerFactor.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) where V : PowerFactor.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) where V : PowerFactor.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<V>) where V : PowerFactor.Value, V.Datatype == Swift.Int64
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: PowerFactor.Expression<V>? = nil, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: PowerFactor.Expression<V>? = nil, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: PowerFactor.Expression<V>? = nil, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: PowerFactor.Expression<V?>, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool>? = nil, defaultValue: V, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: PowerFactor.Expression<V>? = nil, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: PowerFactor.Expression<V?>, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func column<V>(_ name: PowerFactor.Expression<V?>, unique: Swift.Bool = false, check: PowerFactor.Expression<Swift.Bool?>, defaultValue: V, collate: PowerFactor.Collation) where V : PowerFactor.Value, V.Datatype == Swift.String
  final public func primaryKey<T>(_ column: PowerFactor.Expression<T>) where T : PowerFactor.Value
  final public func primaryKey<T, U>(_ compositeA: PowerFactor.Expression<T>, _ b: PowerFactor.Expression<U>) where T : PowerFactor.Value, U : PowerFactor.Value
  final public func primaryKey<T, U, V>(_ compositeA: PowerFactor.Expression<T>, _ b: PowerFactor.Expression<U>, _ c: PowerFactor.Expression<V>) where T : PowerFactor.Value, U : PowerFactor.Value, V : PowerFactor.Value
  final public func unique(_ columns: any PowerFactor.Expressible...)
  final public func unique(_ columns: [any PowerFactor.Expressible])
  final public func check(_ condition: PowerFactor.Expression<Swift.Bool>)
  final public func check(_ condition: PowerFactor.Expression<Swift.Bool?>)
  public enum Dependency : Swift.String {
    case NoAction
    case Restrict
    case SetNull
    case SetDefault
    case Cascade
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public func foreignKey<T>(_ column: PowerFactor.Expression<T>, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<T>, update: PowerFactor.TableBuilder.Dependency? = nil, delete: PowerFactor.TableBuilder.Dependency? = nil) where T : PowerFactor.Value
  final public func foreignKey<T>(_ column: PowerFactor.Expression<T?>, references table: any PowerFactor.QueryType, _ other: PowerFactor.Expression<T>, update: PowerFactor.TableBuilder.Dependency? = nil, delete: PowerFactor.TableBuilder.Dependency? = nil) where T : PowerFactor.Value
  final public func foreignKey<T, U>(_ composite: (PowerFactor.Expression<T>, PowerFactor.Expression<U>), references table: any PowerFactor.QueryType, _ other: (PowerFactor.Expression<T>, PowerFactor.Expression<U>), update: PowerFactor.TableBuilder.Dependency? = nil, delete: PowerFactor.TableBuilder.Dependency? = nil) where T : PowerFactor.Value, U : PowerFactor.Value
  final public func foreignKey<T, U, V>(_ composite: (PowerFactor.Expression<T>, PowerFactor.Expression<U>, PowerFactor.Expression<V>), references table: any PowerFactor.QueryType, _ other: (PowerFactor.Expression<T>, PowerFactor.Expression<U>, PowerFactor.Expression<V>), update: PowerFactor.TableBuilder.Dependency? = nil, delete: PowerFactor.TableBuilder.Dependency? = nil) where T : PowerFactor.Value, U : PowerFactor.Value, V : PowerFactor.Value
  @objc deinit
}
public enum PrimaryKey {
  case `default`
  case autoincrement
  public static func == (a: PowerFactor.PrimaryKey, b: PowerFactor.PrimaryKey) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Module {
  public init(_ name: Swift.String, _ arguments: [any PowerFactor.Expressible])
}
extension PowerFactor.Module : PowerFactor.Expressible {
  public var expression: PowerFactor.Expression<Swift.Void> {
    get
  }
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: PowerFactor.AES.Error, b: PowerFactor.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: PowerFactor.AES.Variant
  @usableFromInline
  final internal let blockMode: any PowerFactor.BlockMode
  @usableFromInline
  final internal let padding: PowerFactor.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any PowerFactor.BlockMode, padding: PowerFactor.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension PowerFactor.AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension PowerFactor.AES : PowerFactor.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
public struct PCBC : PowerFactor.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: PowerFactor.PCBC.Error, b: PowerFactor.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: PowerFactor.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping PowerFactor.CipherOperationOnBlock, encryptionOperation: @escaping PowerFactor.CipherOperationOnBlock) throws -> any PowerFactor.CipherModeWorker
}
@objc @_inheritsConvenienceInitializers @objcMembers open class PWFActivationResponse : ObjectiveC.NSObject {
  @objc open var ActivationToken: Swift.String?
  @objc open var MaskedIdentifier: Swift.String?
  @objc open var CustomerId: Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PWFScreenCreator {
  public class Builder : Swift.Encodable, Swift.Decodable {
    public init()
    public func addLines(_ lines: [PowerFactor.PWFScreenCreator.Line]) -> Self
    public func setBackgroundColor(_ color: Swift.String) -> Self
    public func setTimer(timer: PowerFactor.PWFScreenCreator.Timer) -> Self
    public func setFrame(_ frame: PowerFactor.PWFScreenCreator.Frame) -> Self
    public func setFont(_ font: PowerFactor.PWFScreenCreator.Font) -> Self
    public func setSwitch(confirmationSwitch: PowerFactor.PWFScreenCreator.Switch) -> Self
    public func setHtmlString(base64HtmlString: Swift.String) -> Self
    public func setPDFContent(pdfContent: [Swift.UInt8]) -> Self
    public func setPDFContentBase64(pdfContentBase64: Swift.String) -> Self
    public func setApproveButton(_ button: PowerFactor.PWFScreenCreator.Button) -> Self
    public func setRejectButton(_ button: PowerFactor.PWFScreenCreator.Button) -> Self
    public func setActionBar(actionBar: PowerFactor.PWFScreenCreator.ActionBar) -> Self
    public func build() -> Swift.String
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
  public struct Line : Swift.Codable {
    public class Builder {
      public init()
      public func addColons(_ colons: [PowerFactor.PWFScreenCreator.Colon]) -> Self
      public func build() -> PowerFactor.PWFScreenCreator.Line
      @objc deinit
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Colon : Swift.Codable {
    public class Builder {
      public init()
      public func addRow(_ row: PowerFactor.PWFScreenCreator.Row) -> Self
      public func setAlign(_ align: PowerFactor.PWFScreenCreator.EnumAlign) -> Self
      public func build() -> PowerFactor.PWFScreenCreator.Colon
      @objc deinit
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ActionBar : Swift.Codable {
    public init(title: Swift.String?, backgroundColor: Swift.String?, titleColor: Swift.String?, backIconColor: Swift.String?, isShowStatusBar: Swift.Bool?, icons: [PowerFactor.PWFScreenCreator.Icon]?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct BottomBar : Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Font : Swift.Codable {
    public init(iosFontName: Swift.String?, androidAssetFontFileName: Swift.String?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Border : Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Icon : Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Card : Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Block : Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Row : Swift.Codable {
    public init(text: Swift.String?, color: Swift.String?, textSize: Swift.Float?, textStyle: Swift.Int?, isHtml: Swift.Bool?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Switch : Swift.Codable {
    public init(isSwitchActive: Swift.Bool?, switchTitle: Swift.String?, titleColor: Swift.String?, titleSize: Swift.Float?, margin: Swift.Int?, radius: Swift.Int?, elevation: Swift.Int?, backgroundColor: Swift.String?)
    public init(isSwitchActive: Swift.Bool?, switchTitle: Swift.String?, titleColor: Swift.String?, titleSize: Swift.Float?, margin: Swift.Int?, radius: Swift.Int?, elevation: Swift.Int?, backgroundColor: Swift.String?, description: Swift.String?, descriptionColor: Swift.String?, descriptionSize: Swift.Float?, iconName: Swift.String?, iconColor: Swift.String?)
    public init(isSwitchActive: Swift.Bool?, switchTitle: Swift.String?, titleColor: Swift.String?, titleSize: Swift.Float?, margin: Swift.Int?, radius: Swift.Int?, elevation: Swift.Int?, backgroundColor: Swift.String?, description: Swift.String?, descriptionColor: Swift.String?, descriptionSize: Swift.Float?, iconName: Swift.String?, iconColor: Swift.String?, isSwitchMandatory: Swift.Bool?, showReadMore: Swift.Bool?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Timer : Swift.Codable {
    public init(isActive: Swift.Bool?, timerTextColor: Swift.String?, timeOut: Swift.Int?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Frame : Swift.Codable {
    public init(radius: Swift.Int, margin: Swift.Int, elevation: Swift.Int, isShowLineBorder: Swift.Bool)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Button : Swift.Codable {
    public init(isActive: Swift.Bool?, title: Swift.String?, backgroundColor: Swift.String?, titleColor: Swift.String?, titleSize: Swift.Float?, radius: Swift.Float?, shadow: Swift.Int?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum EnumTypefaceStyle : Swift.Int {
    case normal
    case bold
    case italic
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum EnumAlign : Swift.Int {
    case left
    case center
    case right
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc deinit
}
final public class Connection {
  public enum Location {
    case inMemory
    case temporary
    case uri(Swift.String)
  }
  final public var handle: Swift.OpaquePointer {
    get
  }
  public init(_ location: PowerFactor.Connection.Location = .inMemory, readonly: Swift.Bool = false) throws
  convenience public init(_ filename: Swift.String, readonly: Swift.Bool = false) throws
  @objc deinit
  final public var readonly: Swift.Bool {
    get
  }
  final public var lastInsertRowid: Swift.Int64? {
    get
  }
  final public var changes: Swift.Int {
    get
  }
  final public var totalChanges: Swift.Int {
    get
  }
  final public func execute(_ SQL: Swift.String) throws
  final public func prepare(_ statement: Swift.String, _ bindings: (any PowerFactor.Binding)?...) throws -> PowerFactor.Statement
  final public func prepare(_ statement: Swift.String, _ bindings: [(any PowerFactor.Binding)?]) throws -> PowerFactor.Statement
  final public func prepare(_ statement: Swift.String, _ bindings: [Swift.String : (any PowerFactor.Binding)?]) throws -> PowerFactor.Statement
  @discardableResult
  final public func run(_ statement: Swift.String, _ bindings: (any PowerFactor.Binding)?...) throws -> PowerFactor.Statement
  @discardableResult
  final public func run(_ statement: Swift.String, _ bindings: [(any PowerFactor.Binding)?]) throws -> PowerFactor.Statement
  @discardableResult
  final public func run(_ statement: Swift.String, _ bindings: [Swift.String : (any PowerFactor.Binding)?]) throws -> PowerFactor.Statement
  final public func scalar(_ statement: Swift.String, _ bindings: (any PowerFactor.Binding)?...) throws -> (any PowerFactor.Binding)?
  final public func scalar(_ statement: Swift.String, _ bindings: [(any PowerFactor.Binding)?]) throws -> (any PowerFactor.Binding)?
  final public func scalar(_ statement: Swift.String, _ bindings: [Swift.String : (any PowerFactor.Binding)?]) throws -> (any PowerFactor.Binding)?
  public enum TransactionMode : Swift.String {
    case Deferred
    case Immediate
    case Exclusive
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  final public func transaction(_ mode: PowerFactor.Connection.TransactionMode = .Deferred, block: @escaping () throws -> Swift.Void) throws
  final public func savepoint(_ name: Swift.String = UUID().uuidString, block: @escaping () throws -> Swift.Void) throws
  final public func interrupt()
  final public var busyTimeout: Swift.Double {
    get
    set
  }
  final public func busyHandler(_ callback: ((_ tries: Swift.Int) -> Swift.Bool)?)
  final public func trace(_ callback: ((Swift.String) -> Swift.Void)?)
  final public func updateHook(_ callback: ((_ operation: PowerFactor.Operation, _ db: Swift.String, _ table: Swift.String, _ rowid: Swift.Int64) -> Swift.Void)?)
  final public func commitHook(_ callback: (() throws -> Swift.Void)?)
  final public func rollbackHook(_ callback: (() -> Swift.Void)?)
  final public func createFunction(_ function: Swift.String, argumentCount: Swift.UInt? = nil, deterministic: Swift.Bool = false, _ block: @escaping (_ args: [(any PowerFactor.Binding)?]) -> (any PowerFactor.Binding)?)
  public typealias ComparisonResult = Foundation.ComparisonResult
  final public func createCollation(_ collation: Swift.String, _ block: @escaping (_ lhs: Swift.String, _ rhs: Swift.String) -> PowerFactor.Connection.ComparisonResult) throws
}
extension PowerFactor.Connection : Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
}
extension PowerFactor.Connection.Location : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum Operation {
  case insert
  case update
  case delete
  public static func == (a: PowerFactor.Operation, b: PowerFactor.Operation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SqliteResult : Swift.Error {
  case error(message: Swift.String, code: Swift.Int32, statement: PowerFactor.Statement?)
}
extension PowerFactor.SqliteResult : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class ReadMoreTextView : UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public var onSizeChange: (PowerFactor.ReadMoreTextView) -> ()
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var maximumNumberOfLines: Swift.Int {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var readMoreText: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var attributedReadMoreText: Foundation.NSAttributedString? {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var readLessText: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var attributedReadLessText: Foundation.NSAttributedString? {
    get
    set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var shouldTrim: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public func setNeedsUpdateTrim()
  @_Concurrency.MainActor(unsafe) public var readMoreTextPadding: UIKit.UIEdgeInsets
  @_Concurrency.MainActor(unsafe) public var readLessTextPadding: UIKit.UIEdgeInsets
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var text: Swift.String! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func hitTest(_ point: CoreFoundation.CGPoint, with event: UIKit.UIEvent?) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @objc deinit
}
extension PowerFactor.Module {
  public static func RTree<T, U>(_ primaryKey: PowerFactor.Expression<T>, _ pairs: (PowerFactor.Expression<U>, PowerFactor.Expression<U>)...) -> PowerFactor.Module where T : PowerFactor.Value, U : PowerFactor.Value, T.Datatype == Swift.Int64, U.Datatype == Swift.Double
}
extension PowerFactor.CS.BigUInt : Swift.Strideable {
  public typealias Stride = PowerFactor.CS.BigInt
  public func advanced(by n: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigUInt
  public func distance(to other: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigInt
}
extension PowerFactor.CS.BigInt : Swift.Strideable {
  public typealias Stride = PowerFactor.CS.BigInt
  public func advanced(by n: PowerFactor.CS.BigInt.Stride) -> PowerFactor.CS.BigInt
  public func distance(to other: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt.Stride
}
extension PowerFactor.CS.BigUInt {
  public mutating func subtractReportingOverflow(_ b: PowerFactor.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> Swift.Bool
  public func subtractingReportingOverflow(_ other: PowerFactor.CS.BigUInt, shiftedBy shift: Swift.Int) -> (partialValue: PowerFactor.CS.BigUInt, overflow: Swift.Bool)
  public func subtractingReportingOverflow(_ other: PowerFactor.CS.BigUInt) -> (partialValue: PowerFactor.CS.BigUInt, overflow: Swift.Bool)
  public mutating func subtract(_ other: PowerFactor.CS.BigUInt, shiftedBy shift: Swift.Int = 0)
  public func subtracting(_ other: PowerFactor.CS.BigUInt, shiftedBy shift: Swift.Int = 0) -> PowerFactor.CS.BigUInt
  public mutating func decrement(shiftedBy shift: Swift.Int = 0)
  public static func - (a: PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt) -> PowerFactor.CS.BigUInt
  public static func -= (a: inout PowerFactor.CS.BigUInt, b: PowerFactor.CS.BigUInt)
}
extension PowerFactor.CS.BigInt {
  public mutating func negate()
  public static func - (a: PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt) -> PowerFactor.CS.BigInt
  public static func -= (a: inout PowerFactor.CS.BigInt, b: PowerFactor.CS.BigInt)
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor.Number {
  public var absoluteValue: PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor._OptionalType, Self.UnderlyingType.WrappedType : PowerFactor.Number {
  public var absoluteValue: PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType == Swift.Double {
  public func round(_ precision: Swift.Int? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
}
extension PowerFactor.ExpressionType where Self.UnderlyingType == Swift.Double? {
  public func round(_ precision: Swift.Int? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
}
extension PowerFactor.ExpressionType where Self.UnderlyingType : PowerFactor.Value, Self.UnderlyingType.Datatype == Swift.Int64 {
  public static func random() -> PowerFactor.Expression<Self.UnderlyingType>
}
extension PowerFactor.ExpressionType where Self.UnderlyingType == Foundation.Data {
  public static func random(_ length: Swift.Int) -> PowerFactor.Expression<Self.UnderlyingType>
  public static func allZeros(_ length: Swift.Int) -> PowerFactor.Expression<Self.UnderlyingType>
  public var length: PowerFactor.Expression<Swift.Int> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType == Foundation.Data? {
  public var length: PowerFactor.Expression<Swift.Int?> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType == Swift.String {
  public var length: PowerFactor.Expression<Swift.Int> {
    get
  }
  public var lowercaseString: PowerFactor.Expression<Swift.String> {
    get
  }
  public var uppercaseString: PowerFactor.Expression<Swift.String> {
    get
  }
  public func like(_ pattern: Swift.String, escape character: Swift.Character? = nil) -> PowerFactor.Expression<Swift.Bool>
  public func glob(_ pattern: Swift.String) -> PowerFactor.Expression<Swift.Bool>
  public func match(_ pattern: Swift.String) -> PowerFactor.Expression<Swift.Bool>
  public func regexp(_ pattern: Swift.String) -> PowerFactor.Expression<Swift.Bool>
  public func collate(_ collation: PowerFactor.Collation) -> PowerFactor.Expression<Self.UnderlyingType>
  public func ltrim(_ characters: Swift.Set<Swift.Character>? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public func rtrim(_ characters: Swift.Set<Swift.Character>? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public func trim(_ characters: Swift.Set<Swift.Character>? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public func replace(_ pattern: Swift.String, with replacement: Swift.String) -> PowerFactor.Expression<Self.UnderlyingType>
  public func substring(_ location: Swift.Int, length: Swift.Int? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public subscript(range: Swift.Range<Swift.Int>) -> PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
}
extension PowerFactor.ExpressionType where Self.UnderlyingType == Swift.String? {
  public var length: PowerFactor.Expression<Swift.Int?> {
    get
  }
  public var lowercaseString: PowerFactor.Expression<Swift.Optional<Swift.String>> {
    get
  }
  public var uppercaseString: PowerFactor.Expression<Swift.Optional<Swift.String>> {
    get
  }
  public func like(_ pattern: Swift.String, escape character: Swift.Character? = nil) -> PowerFactor.Expression<Swift.Bool?>
  public func glob(_ pattern: Swift.String) -> PowerFactor.Expression<Swift.Bool?>
  public func match(_ pattern: Swift.String) -> PowerFactor.Expression<Swift.Bool>
  public func regexp(_ pattern: Swift.String) -> PowerFactor.Expression<Swift.Bool?>
  public func collate(_ collation: PowerFactor.Collation) -> PowerFactor.Expression<Self.UnderlyingType>
  public func ltrim(_ characters: Swift.Set<Swift.Character>? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public func rtrim(_ characters: Swift.Set<Swift.Character>? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public func trim(_ characters: Swift.Set<Swift.Character>? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public func replace(_ pattern: Swift.String, with replacement: Swift.String) -> PowerFactor.Expression<Self.UnderlyingType>
  public func substring(_ location: Swift.Int, length: Swift.Int? = nil) -> PowerFactor.Expression<Self.UnderlyingType>
  public subscript(range: Swift.Range<Swift.Int>) -> PowerFactor.Expression<Self.UnderlyingType> {
    get
  }
}
public func ?? <V>(optional: PowerFactor.Expression<V?>, defaultValue: V) -> PowerFactor.Expression<V> where V : PowerFactor.Value
public func ?? <V>(optional: PowerFactor.Expression<V?>, defaultValue: PowerFactor.Expression<V>) -> PowerFactor.Expression<V> where V : PowerFactor.Value
public func ?? <V>(optional: PowerFactor.Expression<V?>, defaultValue: PowerFactor.Expression<V?>) -> PowerFactor.Expression<V> where V : PowerFactor.Value
extension PowerFactor.Connection {
  final public func createFunction<Z>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping () -> Z) throws -> (() -> PowerFactor.Expression<Z>) where Z : PowerFactor.Value
  final public func createFunction<Z>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping () -> Z?) throws -> (() -> PowerFactor.Expression<Z?>) where Z : PowerFactor.Value
  final public func createFunction<Z, A>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A) -> Z) throws -> ((PowerFactor.Expression<A>) -> PowerFactor.Expression<Z>) where Z : PowerFactor.Value, A : PowerFactor.Value
  final public func createFunction<Z, A>(function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?) -> Z) throws -> ((PowerFactor.Expression<A?>) -> PowerFactor.Expression<Z>) where Z : PowerFactor.Value, A : PowerFactor.Value
  final public func createFunction<Z, A>(function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A) -> Z?) throws -> ((PowerFactor.Expression<A>) -> PowerFactor.Expression<Z?>) where Z : PowerFactor.Value, A : PowerFactor.Value
  final public func createFunction<Z, A>(function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?) -> Z?) throws -> ((PowerFactor.Expression<A?>) -> PowerFactor.Expression<Z?>) where Z : PowerFactor.Value, A : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B) -> Z) throws -> (PowerFactor.Expression<A>, PowerFactor.Expression<B>) -> PowerFactor.Expression<Z> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B) -> Z) throws -> (PowerFactor.Expression<A?>, PowerFactor.Expression<B>) -> PowerFactor.Expression<Z> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B?) -> Z) throws -> (PowerFactor.Expression<A>, PowerFactor.Expression<B?>) -> PowerFactor.Expression<Z> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B) -> Z?) throws -> (PowerFactor.Expression<A>, PowerFactor.Expression<B>) -> PowerFactor.Expression<Z?> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B?) -> Z) throws -> (PowerFactor.Expression<A?>, PowerFactor.Expression<B?>) -> PowerFactor.Expression<Z> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B) -> Z?) throws -> (PowerFactor.Expression<A?>, PowerFactor.Expression<B>) -> PowerFactor.Expression<Z?> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A, B?) -> Z?) throws -> (PowerFactor.Expression<A>, PowerFactor.Expression<B?>) -> PowerFactor.Expression<Z?> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
  final public func createFunction<Z, A, B>(_ function: Swift.String, deterministic: Swift.Bool = false, _ block: @escaping (A?, B?) -> Z?) throws -> (PowerFactor.Expression<A?>, PowerFactor.Expression<B?>) -> PowerFactor.Expression<Z?> where Z : PowerFactor.Value, A : PowerFactor.Value, B : PowerFactor.Value
}
public class ClearMessage : PowerFactor.Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  convenience public init(string: Swift.String, using encoding: Swift.String.Encoding) throws
  public func string(encoding: Swift.String.Encoding) throws -> Swift.String
  public func encrypted(with key: PowerFactor.PublicKey, padding: PowerFactor.Paddings) throws -> PowerFactor.EncryptedMessage
  public func signed(with key: PowerFactor.PrivateKey, digestType: PowerFactor.Signature.DigestType) throws -> PowerFactor.Signature
  public func verify(with key: PowerFactor.PublicKey, signature: PowerFactor.Signature, digestType: PowerFactor.Signature.DigestType) throws -> Swift.Bool
  @objc deinit
}
extension PowerFactor.CS.BigUInt {
  public func squareRoot() -> PowerFactor.CS.BigUInt
}
extension PowerFactor.CS.BigInt {
  public func squareRoot() -> PowerFactor.CS.BigInt
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: PowerFactor.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: PowerFactor.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: PowerFactor.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: PowerFactor.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension PowerFactor.SHA2 : PowerFactor.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
public enum ClientTransactionApprovementType : Swift.Int {
  case StandardTransactionApprovement
  case PIN
  case Biometry
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objcMembers open class TransactionOwnerContract : PowerFactor.PWFBaseObject {
  @objc open var OwnerKey: Swift.String?
  override open func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
}
@objc public enum TransactionTypes : Swift.Int {
  case clientTransaction = 1, mobileApproval = 2, OneTouchTransaction = 3, QRTransaction = 4, soft_otp = 5, vpn_transaction = 6
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class BlockDecryptor : PowerFactor.Cryptor, PowerFactor.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: PowerFactor.Padding
  @usableFromInline
  internal var worker: any PowerFactor.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PowerFactor.Padding, _ worker: any PowerFactor.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public class PrivateKey : PowerFactor.Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  @objc deinit
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> any PowerFactor.Cryptor & PowerFactor.Updatable
  func makeDecryptor() throws -> any PowerFactor.Cryptor & PowerFactor.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension PowerFactor.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
@usableFromInline
final internal class StreamDecryptor : PowerFactor.Cryptor, PowerFactor.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any PowerFactor.CipherModeWorker
  @usableFromInline
  final internal let padding: PowerFactor.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: PowerFactor.Padding, _ worker: any PowerFactor.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
extension PowerFactor.CMAC.Error : Swift.Equatable {}
extension PowerFactor.CMAC.Error : Swift.Hashable {}
extension PowerFactor.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension PowerFactor.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension PowerFactor.CipherError : Swift.Equatable {}
extension PowerFactor.CipherError : Swift.Hashable {}
extension PowerFactor.RSA.Error : Swift.Equatable {}
extension PowerFactor.RSA.Error : Swift.Hashable {}
extension PowerFactor.Padding : Swift.Equatable {}
extension PowerFactor.Padding : Swift.Hashable {}
extension PowerFactor.GCM.Mode : Swift.Equatable {}
extension PowerFactor.GCM.Mode : Swift.Hashable {}
extension PowerFactor.GCM.Error : Swift.Equatable {}
extension PowerFactor.GCM.Error : Swift.Hashable {}
extension PowerFactor.FTSConfig.ColumnOption : Swift.Equatable {}
extension PowerFactor.FTSConfig.ColumnOption : Swift.Hashable {}
extension PowerFactor.FTS4Config.MatchInfo : Swift.Equatable {}
extension PowerFactor.FTS4Config.MatchInfo : Swift.Hashable {}
extension PowerFactor.FTS4Config.Order : Swift.Equatable {}
extension PowerFactor.FTS4Config.Order : Swift.Hashable {}
extension PowerFactor.Token.Kind : Swift.Equatable {}
extension PowerFactor.Token.Kind : Swift.Hashable {}
extension PowerFactor.Token.Kind : Swift.RawRepresentable {}
extension PowerFactor._objc_Signature.DigestType : Swift.Equatable {}
extension PowerFactor._objc_Signature.DigestType : Swift.Hashable {}
extension PowerFactor._objc_Signature.DigestType : Swift.RawRepresentable {}
extension PowerFactor.CCM : PowerFactor.BlockMode {}
extension PowerFactor.CCM.Error : Swift.Equatable {}
extension PowerFactor.CCM.Error : Swift.Hashable {}
extension PowerFactor.QRTransactionStatus : Swift.Equatable {}
extension PowerFactor.QRTransactionStatus : Swift.Hashable {}
extension PowerFactor.QRTransactionStatus : Swift.RawRepresentable {}
extension PowerFactor.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension PowerFactor.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension PowerFactor.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension PowerFactor.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension PowerFactor.CBC.Error : Swift.Equatable {}
extension PowerFactor.CBC.Error : Swift.Hashable {}
extension PowerFactor.PWFClientLogTypes : Swift.Equatable {}
extension PowerFactor.PWFClientLogTypes : Swift.Hashable {}
extension PowerFactor.PWFClientLogTypes : Swift.RawRepresentable {}
extension PowerFactor.Signature.DigestType : Swift.Equatable {}
extension PowerFactor.Signature.DigestType : Swift.Hashable {}
extension PowerFactor.HMAC.Error : Swift.Equatable {}
extension PowerFactor.HMAC.Error : Swift.Hashable {}
extension PowerFactor.ChaCha20.Error : Swift.Equatable {}
extension PowerFactor.ChaCha20.Error : Swift.Hashable {}
extension PowerFactor.CS.BigInt.Sign : Swift.Equatable {}
extension PowerFactor.CS.BigInt.Sign : Swift.Hashable {}
extension PowerFactor.JoinType : Swift.Equatable {}
extension PowerFactor.JoinType : Swift.Hashable {}
extension PowerFactor.JoinType : Swift.RawRepresentable {}
extension PowerFactor.OnConflict : Swift.Equatable {}
extension PowerFactor.OnConflict : Swift.Hashable {}
extension PowerFactor.OnConflict : Swift.RawRepresentable {}
extension PowerFactor.SHA3.Variant : Swift.Equatable {}
extension PowerFactor.SHA3.Variant : Swift.Hashable {}
extension PowerFactor.HKDF.Error : Swift.Equatable {}
extension PowerFactor.HKDF.Error : Swift.Hashable {}
extension PowerFactor.PWFConfig.`Type` : Swift.Equatable {}
extension PowerFactor.PWFConfig.`Type` : Swift.Hashable {}
extension PowerFactor.Rabbit.Error : Swift.Equatable {}
extension PowerFactor.Rabbit.Error : Swift.Hashable {}
extension PowerFactor.CTR : PowerFactor.BlockMode {}
extension PowerFactor.CTR.Error : Swift.Equatable {}
extension PowerFactor.CTR.Error : Swift.Hashable {}
extension PowerFactor.Blowfish.Error : Swift.Equatable {}
extension PowerFactor.Blowfish.Error : Swift.Hashable {}
extension PowerFactor.OFB.Error : Swift.Equatable {}
extension PowerFactor.OFB.Error : Swift.Hashable {}
extension PowerFactor.CFB.Error : Swift.Equatable {}
extension PowerFactor.CFB.Error : Swift.Hashable {}
extension PowerFactor.CFB.SegmentSize : Swift.Equatable {}
extension PowerFactor.CFB.SegmentSize : Swift.Hashable {}
extension PowerFactor.CFB.SegmentSize : Swift.RawRepresentable {}
extension PowerFactor.FTS5Config.Detail : Swift.Equatable {}
extension PowerFactor.FTS5Config.Detail : Swift.Hashable {}
extension PowerFactor.TransactionStatusNames : Swift.Equatable {}
extension PowerFactor.TransactionStatusNames : Swift.Hashable {}
extension PowerFactor.TransactionStatusNames : Swift.RawRepresentable {}
extension PowerFactor.RSA.RSAEncryptionVariant : Swift.Equatable {}
extension PowerFactor.RSA.RSAEncryptionVariant : Swift.Hashable {}
extension PowerFactor.SignatureError : Swift.Equatable {}
extension PowerFactor.SignatureError : Swift.Hashable {}
extension PowerFactor.SwKeyStore.SecError : Swift.Equatable {}
extension PowerFactor.SwKeyStore.SecError : Swift.Hashable {}
extension PowerFactor.SwKeyStore.SecError : Swift.RawRepresentable {}
extension PowerFactor.SwKeyConvert.SwError : Swift.Equatable {}
extension PowerFactor.SwKeyConvert.SwError : Swift.Hashable {}
extension PowerFactor.PEM.EncryptedPrivateKey.EncMode : Swift.Equatable {}
extension PowerFactor.PEM.EncryptedPrivateKey.EncMode : Swift.Hashable {}
extension PowerFactor.CC.CCError : Swift.Equatable {}
extension PowerFactor.CC.CCError : Swift.Hashable {}
extension PowerFactor.CC.CCError : Swift.RawRepresentable {}
extension PowerFactor.CC.DigestAlgorithm : Swift.Equatable {}
extension PowerFactor.CC.DigestAlgorithm : Swift.Hashable {}
extension PowerFactor.CC.DigestAlgorithm : Swift.RawRepresentable {}
extension PowerFactor.CC.HMACAlg : Swift.Equatable {}
extension PowerFactor.CC.HMACAlg : Swift.Hashable {}
extension PowerFactor.CC.HMACAlg : Swift.RawRepresentable {}
extension PowerFactor.CC.OpMode : Swift.Equatable {}
extension PowerFactor.CC.OpMode : Swift.Hashable {}
extension PowerFactor.CC.OpMode : Swift.RawRepresentable {}
extension PowerFactor.CC.BlockMode : Swift.Equatable {}
extension PowerFactor.CC.BlockMode : Swift.Hashable {}
extension PowerFactor.CC.BlockMode : Swift.RawRepresentable {}
extension PowerFactor.CC.AuthBlockMode : Swift.Equatable {}
extension PowerFactor.CC.AuthBlockMode : Swift.Hashable {}
extension PowerFactor.CC.AuthBlockMode : Swift.RawRepresentable {}
extension PowerFactor.CC.Algorithm : Swift.Equatable {}
extension PowerFactor.CC.Algorithm : Swift.Hashable {}
extension PowerFactor.CC.Algorithm : Swift.RawRepresentable {}
extension PowerFactor.CC.Padding : Swift.Equatable {}
extension PowerFactor.CC.Padding : Swift.Hashable {}
extension PowerFactor.CC.Padding : Swift.RawRepresentable {}
extension PowerFactor.CC.RSA.AsymmetricPadding : Swift.Equatable {}
extension PowerFactor.CC.RSA.AsymmetricPadding : Swift.Hashable {}
extension PowerFactor.CC.RSA.AsymmetricPadding : Swift.RawRepresentable {}
extension PowerFactor.CC.RSA.AsymmetricSAPadding : Swift.Equatable {}
extension PowerFactor.CC.RSA.AsymmetricSAPadding : Swift.Hashable {}
extension PowerFactor.CC.RSA.AsymmetricSAPadding : Swift.RawRepresentable {}
extension PowerFactor.CC.DH.DHParam : Swift.Equatable {}
extension PowerFactor.CC.DH.DHParam : Swift.Hashable {}
extension PowerFactor.CC.CRC.Mode : Swift.Equatable {}
extension PowerFactor.CC.CRC.Mode : Swift.Hashable {}
extension PowerFactor.CC.CRC.Mode : Swift.RawRepresentable {}
extension PowerFactor.CC.KeyDerivation.PRFAlg : Swift.Equatable {}
extension PowerFactor.CC.KeyDerivation.PRFAlg : Swift.Hashable {}
extension PowerFactor.CC.KeyDerivation.PRFAlg : Swift.RawRepresentable {}
extension PowerFactor.OCB.Mode : Swift.Equatable {}
extension PowerFactor.OCB.Mode : Swift.Hashable {}
extension PowerFactor.OCB.Error : Swift.Equatable {}
extension PowerFactor.OCB.Error : Swift.Hashable {}
extension PowerFactor.KeychainItemAccessibility : Swift.Equatable {}
extension PowerFactor.KeychainItemAccessibility : Swift.Hashable {}
extension PowerFactor.Poly1305.Error : Swift.Equatable {}
extension PowerFactor.Poly1305.Error : Swift.Hashable {}
extension PowerFactor.RSA.SignatureVariant : Swift.Equatable {}
extension PowerFactor.RSA.SignatureVariant : Swift.Hashable {}
extension PowerFactor.Bit : Swift.Equatable {}
extension PowerFactor.Bit : Swift.Hashable {}
extension PowerFactor.Bit : Swift.RawRepresentable {}
extension PowerFactor.TableBuilder.Dependency : Swift.Equatable {}
extension PowerFactor.TableBuilder.Dependency : Swift.Hashable {}
extension PowerFactor.TableBuilder.Dependency : Swift.RawRepresentable {}
extension PowerFactor.PrimaryKey : Swift.Equatable {}
extension PowerFactor.PrimaryKey : Swift.Hashable {}
extension PowerFactor.AES.Error : Swift.Equatable {}
extension PowerFactor.AES.Error : Swift.Hashable {}
extension PowerFactor.AES.Variant : Swift.Equatable {}
extension PowerFactor.AES.Variant : Swift.Hashable {}
extension PowerFactor.AES.Variant : Swift.RawRepresentable {}
extension PowerFactor.PCBC.Error : Swift.Equatable {}
extension PowerFactor.PCBC.Error : Swift.Hashable {}
extension PowerFactor.PWFScreenCreator.EnumTypefaceStyle : Swift.Equatable {}
extension PowerFactor.PWFScreenCreator.EnumTypefaceStyle : Swift.Hashable {}
extension PowerFactor.PWFScreenCreator.EnumTypefaceStyle : Swift.RawRepresentable {}
extension PowerFactor.PWFScreenCreator.EnumAlign : Swift.Equatable {}
extension PowerFactor.PWFScreenCreator.EnumAlign : Swift.Hashable {}
extension PowerFactor.PWFScreenCreator.EnumAlign : Swift.RawRepresentable {}
extension PowerFactor.Connection.TransactionMode : Swift.Equatable {}
extension PowerFactor.Connection.TransactionMode : Swift.Hashable {}
extension PowerFactor.Connection.TransactionMode : Swift.RawRepresentable {}
extension PowerFactor.Operation : Swift.Equatable {}
extension PowerFactor.Operation : Swift.Hashable {}
extension PowerFactor.SHA2.Variant : Swift.Equatable {}
extension PowerFactor.SHA2.Variant : Swift.Hashable {}
extension PowerFactor.SHA2.Variant : Swift.Sendable {}
extension PowerFactor.ClientTransactionApprovementType : Swift.Equatable {}
extension PowerFactor.ClientTransactionApprovementType : Swift.Hashable {}
extension PowerFactor.ClientTransactionApprovementType : Swift.RawRepresentable {}
extension PowerFactor.TransactionTypes : Swift.Equatable {}
extension PowerFactor.TransactionTypes : Swift.Hashable {}
extension PowerFactor.TransactionTypes : Swift.RawRepresentable {}
